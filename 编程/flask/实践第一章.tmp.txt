<!DOCTYPE html><html lang="zh-cmn"><head> <script>console.log('weixin://preInjectJSBridge/start');</script> <meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="renderer" content="webkit">  <meta name="viewport" content="viewport-fit=cover,width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0">  <meta name="format-detection" content="telephone=no">  <title>weixin://private/wechat_user_redirect/http://dldir1.qq.com/foxmail/weread_android_4.1.2.581_59.apk</title><link rel="dns-prefetch" href="//rescdn.qqmail.com"><link rel="icon" type="image/png" sizes="16x16" href="https://rescdn.qqmail.com/node/wr/wrwxnovel/style/images/independent/favicon/favicon_16h$cbb35dd7.png"><link rel="icon" type="image/png" sizes="32x32" href="https://rescdn.qqmail.com/node/wr/wrwxnovel/style/images/independent/favicon/favicon_32h$d31ebf46.png"><link rel="icon" type="image/png" sizes="48x48" href="https://rescdn.qqmail.com/node/wr/wrwxnovel/style/images/independent/favicon/favicon_48h$f947721f.png"><link rel="apple-touch-icon" sizes="57x57" href="https://rescdn.qqmail.com/node/wr/wrwxnovel/style/images/independent/appleTouchIcon/apple-touch-icon-57x57$05b99fde.png"><link rel="apple-touch-icon" sizes="72x72" href="https://rescdn.qqmail.com/node/wr/wrwxnovel/style/images/independent/appleTouchIcon/apple-touch-icon-72x72$3678ba08.png"><link rel="apple-touch-icon" sizes="114x114" href="https://rescdn.qqmail.com/node/wr/wrwxnovel/style/images/independent/appleTouchIcon/apple-touch-icon-114x114$b1f639a1.png"><link rel="apple-touch-icon" sizes="120x120" href="https://rescdn.qqmail.com/node/wr/wrwxnovel/style/images/independent/appleTouchIcon/apple-touch-icon-120x120$46a7e4f8.png"><link rel="apple-touch-icon" sizes="144x144" href="https://rescdn.qqmail.com/node/wr/wrwxnovel/style/images/independent/appleTouchIcon/apple-touch-icon-144x144$b28bea82.png"><link rel="apple-touch-icon" sizes="152x152" href="https://rescdn.qqmail.com/node/wr/wrwxnovel/style/images/independent/appleTouchIcon/apple-touch-icon-152x152$4a40738e.png">     <link rel="stylesheet" type="text/css" href="https://rescdn.qqmail.com/node/wr/wrwxnovel/style/css/WeChatSearch/verticalReader$acbeabbb.css">    <script>window.config = {
            ref: 'mp',
            pageName: 'wechat_search_read',
            pageNick: '',
            platform: 'unknown',
            isLogin: 'true' == 'true',
            reportUrl: '/wrpage/report',
            pageLink: '/wrpage/',
            debug: 'false' === 'true',
            wrVer: '',
            shareIcon: 'https://rescdn.qqmail.com/node/wr/wrwxnovel/style/images/independent/shareIcon/default$4c28a643.png'
        };
        (function (root) {

            var fnList = [];

            var isReady = false;

            root.ready = function (requires, fn)
            {
                if (requires == null)
                {
                    isReady = true;
                    for (var i = 0, len = fnList.length; i < len; i++)
                    {
                        try
                        {
                            _.use(fnList[i].requires, fnList[i].fn);
                        } catch (e)
                        {
                            if (config.debug) throw e;
                            if (_.badJsReport && _.badJsReport.report) _.badJsReport.report(e);
                        }
                    }
                    fnList = [];

                    return;
                }

                if (fn == null)
                {
                    fn = requires;
                    requires = [];
                }

                if (isReady)
                {
                    try
                    {
                        _.use(requires, fn);
                    } catch (e)
                    {
                        if (_.badJsReport && _.badJsReport.report) _.badJsReport.report(e);
                    }

                    return;
                }

                fnList.push({
                    fn: fn,
                    requires: requires
                });
            };

            root.onload = function() { 
                setTimeout(function() {
                    if(!window.performance || !window.performance.timing) return;
                    var data = 'key=' + '80000542';
                    data += '&vid=' + encodeURIComponent('8186776');
                    data += '&platform=' + encodeURIComponent('unknown');
                    data += '&os=' + encodeURIComponent('weixin');
                    data += '&appversion=' + encodeURIComponent('0');
                    data += '&params=' + encodeURIComponent('wechat_search_read');
                    var timing = window.performance.timing;
                    var dnsTime = timing.domainLookupEnd - timing.domainLookupStart;
                    var conTime = timing.connectEnd - timing.connectStart;
                    var reqTime = timing.responseEnd - timing.requestStart;
                    var domTime = timing.domInteractive - timing.domLoading;
                    var resTime = timing.domComplete - timing.domInteractive;
                    var allTime = timing.loadEventEnd - timing.fetchStart;
                    data += '&params=' + encodeURIComponent(dnsTime); // DNS查询的开始和结束时间节点
                    data += '&params=' + encodeURIComponent(conTime); // TCP建立连接和连接成功的时间节点
                    data += '&params=' + encodeURIComponent(reqTime); // 浏览器收到从服务器端（或缓存、本地资源）响应回的第一个字节和最后一个字节数据的时刻
                    data += '&params=' + encodeURIComponent(domTime); // 代表html文档解析完毕（即dom tree创建完成）但是内嵌资源（比如外链css、js等）还未加载的时间点
                    data += '&params=' + encodeURIComponent(resTime); // 文档和所有子资源已解析并完成加载
                    data += '&params=' + encodeURIComponent(allTime);
                    var xmlhttp = new XMLHttpRequest();
                    xmlhttp.open('POST','/wrpage/log/apposslog', true);
                    xmlhttp.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
                    xmlhttp.send(data);
                }, 0);
            }; 
        })(window);</script>  <script>config.vid = +'8186776';</script>  </head><body ontouchstart="">  <div id="weread.layout.normal_layout_$" rendered="true"><div class="frame_body" id="weread.layout.normal_layout$layout$"><div id="wrpage.WeChatSearch.verticalReader_$" rendered="true"><div class="verticalReader_wrap js_reader"><!----><!----><div class="verticalReader_main"><div class="verticalReader_chapter"><!----><div class="verticalReader_chapter_title">第7章 留言板</div><div class="verticalReader_chapter_content"><p>第7章 留言板</p><p>第一个示例程序是一个非常简单的留言板程序Say Hello，编写时涉及的知识完全是我们在第一部分学习的内容。这一章，我们会基于这个程序介绍一种组织项目代码的形式。在程序的编写过程中，我们还会了解Web程序的开发流程，对第一部分学习的基础内容进行一个简单的回顾和复习，并学习几个新的Flask扩展。</p><p>本章新涉及的Python包如下所示：</p><p>❑ Bootstrap-Flask（0.1.0）</p><p>❍主页：https://github.com/greyli/bootstrap-flask</p><p>❍文档：https://bootstrap-flask.readthedocs.io</p><p>❑ Flask-Moment（0.6.0）</p><p>❍主页：https://github.com/miguelgrinberg/Flask-Moment</p><p>❑ Faker（0.8.13）</p><p>❍主页：https://github.com/joke2k/faker</p><p>❍文档：http://faker.readthedocs.io</p><p>❑ Flask-Debug Toolbar（0.10.1）</p><p>❍主页：https://github.com/mgood/flask-debugtoolbar</p><p>❍文档：https://flask-debugtoolbar.readthedocs.io</p><p>请打开一个新的命令行窗口，切换到合适的目录，然后使用下面的命令将示例程序仓库复制到本地：</p><p>$ git clone https://github.com/greyli/sayhello.git</p><p>提示</p><p>如果你在Say Hello的Git Hub页面（https://github.com/greyli/sayhello）页面单击了Fork按钮，那么可以使用你自己的Git Hub用户名来替换上面的greyli，这将复制一份派生仓库，你可以自由地修改和提交代码。</p><p>接着，切换到项目文件夹中，使用Pipenv创建虚拟环境，这会同时安装所有依赖（--dev选项用来包括开发依赖），这应该会花费一些时间，安装完成后激活虚拟环境：</p><p>$ cd sayhello         $ pipenv install --dev         $ pipenv shell</p><p>最后创建虚拟数据（flask forge是用来生成虚拟数据的自定义命令，我们会在后面详细介绍），并启动程序：</p><p>$ flask forge         $ flask run</p><p>在浏览器访问http://127.0.0.1:5000或http://localhost:5000即可体验我们本章要实现的Say Hello程序。</p><p>注意</p><p>和本书第一部分的示例程序相同，第二部分所有的示例程序都运行在本地机的5000端口，即http://localhost:5000，确保没有其他程序同时在运行。</p><p>注意</p><p>因为所有示例程序的CSS文件名称、Java Script文件名称以及Favicon文件名称均相同，为了避免浏览器对不同示例程序中同名的文件进行缓存，请在第一次运行新的示例程序后按下Crtl+F5或Shift+F5清除缓存。</p><p>阅读源码时，可以使用下面的命令签出初始版本：</p><p>$ git checkout package</p><p>使用git tag-n命令可以列出项目包含的所有标签，在对应的章节中我也会给出签出提示，每一个版本的程序都可以运行。你也可以在Git Hub上阅读代码，Say Hello的Git Hub主页为（https://github.com/greyli/sayhello），通过branch下拉列表中的Tags标签可以查看不同标签的源码。</p><p>提示</p><p>在Git Hub上也可以查看不同标签之间的程序代码变化，比如，第一个标签package和第二个标签bootstrap的源码变动对比可以访问https://github.com/greyli/sayhello/compare/package...bootstrap查看，其他标签以此类推。</p><p>7.1 使用包组织代码</p><p>本书第一部分的示例程序都采用单脚本的形式存储代码。随着项目逐渐变大，把所有的代码都放在app.py里会导致可读性降低，不方便管理，我们需要更好的代码组织方式。</p><p>Flask对项目的组织方式没有要求。对于小型项目，你完全可以把代码都放在一个主模块里，这也是第一部分的示例程序的组织方式。随着项目越来越大，更好的处理方式是将单一的模块升级为包（Package），把不同部分的代码分模块存放。</p><p>附注</p><p>在Python中，每一个有效的Python文件（.py）都是模块。每一个包含__init__.py文件的文件夹都被视作包，包让你可以使用文件夹来组织模块。__init__.py文件通常被称作构造文件，文件可以为空，也可以用来放置包的初始化代码。当包或包内的模块被导入时，构造文件将被自动执行。</p><p>Say Hello程序的核心组件都放到一个包中，这个包称为程序包，包的名称通常使用程序名称，即sayhello，有时为了方便管理也会使用app作为包名称。除了程序代码，一个基本的Flask项目还包括其他必要的组件，表7-1列出了当前程序包的主要组件及其功能说明。</p><p>表7-1 Say Hello程序包组件和结构</p><p>
在后面的开发中，各类代码都会按照类别存储在对应的模块中。这里的模块并不是固定的，如果你需要组织其他代码，那么可以自己创建对应的模块。比如，你可以创建一个callbacks.py脚本来存储各种注册在程序实例上的处理函数。相对的，如果你不需要创建自定义命令，那么也可以不创建commands.py脚本。</p><p>7.1.1 配置文件</p><p>在Flask中，配置不仅可以通过config对象直接写入，还可以从文件中读取。在Say Hello中，把配置移动到一个单独的文件中，将其命名为settings.py（也常被命名为config.py）。当在单独的文件中定义配置时，不再使用config对象添加配置，而是直接以键值对的方式写出，和保存环境变量的.flaskenv文件非常相似。代码清单7-1是当前的配置文件。</p><p>代码清单7-1 sayhello/settings.py：配置文件</p><p>import os         from sayhello import app               dev_db = 'sqlite:///' + os.path.join(os.path.dirname(app.root_path), 'data.db')         SECRET_KEY = os.getenv('SECRET_KEY', 'secret string')         SQLALCHEMY_TRACK_MODIFICATIONS = False         SQLALCHEMY_DATABASE_URI = os.getenv('DATABASE_URI', dev_db)</p><p>提示</p><p>除了从Python脚本导入配置，Flask还提供了其他方式，比如使用from_json()方法从JSON文件中导入，或是使用from_object()方法从Python对象导入，详情见http://flask.pocoo.org/docs/latest/config/。</p><p>上面的配置和第一部分的示例程序相比有一点变化，由于配置文件被放到了程序包内，为了定位到位于项目根目录的数据库文件，使用os.path.dirname(app.root_path)获取上层目录， app.root_path属性存储程序实例所在的路径。数据库URL和密钥都会首先从环境变量获取。</p><p>在创建程序实例后，使用config对象的from_pyfile()方法即可加载配置，传入配置模块的文件名作为参数：</p><p>...         app = Flask(__name__)         app.config.from_pyfile('settings.py')</p><p>7.1.2 创建程序实例</p><p>使用包组织程序代码后，创建程序实例、初始化扩展等操作可以在程序包的构造文件（__init__.py）中实现，如代码清单7-2所示。</p><p>代码清单7-2 sayhello/__init__.py：创建程序实例、初始化扩展</p><p>from flask import Flask         from flask_sqlalchemy import SQLAlchemy         app = Flask('sayhello')         app.config.from_pyfile('settings.py')         app.jinja_env.trim_blocks = True         app.jinja_env.lstrip_blocks = True         db = SQLAlchemy(app)         from sayhello import views, errors, commands</p><p>在单脚本中创建程序实例时，我们传入__name__变量作为Flask类构造方法的import_name参数值。因为Flask通过这个值来确认程序路径，当使用包组织代码时，为了确保其他扩展或测试框架获得正确的路径值，我们最好以硬编码的形式写出包名称作为程序名称，即sayhello。</p><p>提示</p><p>除了直接写出包名称，你也可以从__name__变量获取包名称，即app = Flask(__name__.split('.')[0])。</p><p>当我们启动程序时，首先被执行的是包含程序实例的脚本，即构造文件。但注册在程序实例上的各种处理程序均存放在其他脚本中，比如视图函数存放在views.py中、错误处理函数则存放在errors.py中。如果不被执行，那么这些视图函数和错误处理函数就不会注册到程序上，那么程序也无法正常运行。为了让使用程序实例app注册的视图函数，错误处理函数，自定义命令函数等和程序实例关联起来，我们需要在构造文件中导入这些模块。因为这些模块也需要从构造文件中导入程序实例，所以为了避免循环依赖，这些导入语句在构造文件的末尾定义。</p><p>提示</p><p>从构造文件中导入变量时不需要注明构造文件的路径，只需要从包名称导入，比如导入在构造文件中定义的程序实例app可以使用from sayhello import app。</p><p>在前面的章节中说过，Flask在通过FLASK_APP环境变量定义的模块中寻找程序实例。所以在启动程序前，我们需要给．flaskenv中的环境变量FLASK_APP重新赋值，这里仅写出包名称即可：</p><p>...         FLASK_APP=sayhello</p><p>

7.2 Web程序开发流程</p><p>在实际的开发中，一个Web程序的开发过程要涉及多个角色，比如客户（提出需求）、项目经理（决定需求的实现方式）、开发者（实现需求）等，在这里我们假设是一个人全职开发。一般来说，一个Web程序的开发流程如下所示：</p><p>
1）分析需求，列出功能清单或写需求说明书。
2）设计程序功能，写功能规格书和技术规格书。
3）进入开发与测试的迭代。
4）调试和性能等专项测试。
5）部署上线（deployment）。
6）运行维护与营销等。
写好功能规格书后，我们就可以进行实际的代码编写。在具体的开发中，代码编写主要分为前端页面（front end）和后端程序（back end）。
前端开发的主要流程如下：</p><p>
1）根据功能规格书画页面草图（sketching）。</p><p>
2）根据草图做交互式原型图（prototyping）。</p><p>
3）根据原型图开发前端页面（HTML、CSS、Java Script）。</p><p>

后端开发的主要流程如下：</p><p>
1）数据库建模。</p><p>
2）编写表单类。</p><p>
3）编写视图函数和相关的处理函数。</p><p>
4）在页面中使用Jinja2替换虚拟数据。</p><p>

采用这个流程并不是必须的，对于非常简单的程序（比如本章的Say Hello），你可以根据情况来省略某些步骤。如果不是只有简单的几个页面的玩具程序，那么我建议你遵循这个过程进行开发。因为如果没有规划，就会像没头苍蝇一样乱飞乱撞，最终开发出不完善的程序，或是添加了无关紧要的功能。从一开始就遵循开发流程，可以让你很容易适应大型程序的开发。想象一下，在大型程序里常常有着复杂的数据库关系，大量的页面和功能，想到哪写到哪会将大量时间都浪费在无意义的调试和删改中。前期考虑和规划越周全，在实际开发时就可以越高效和省力。</p><p>为了便于组织内容，开发时非常重要的测试，我们移动到本书的第三部分进行介绍，但是在实际开发中应该将测试融入整个开发流程中：每编写一部分代码，立刻编写对应的测试。在第三部分我们还会介绍程序的部署以及部署前的准备（性能优化）。</p><p>提示</p><p>为了不偏离主题，我们这里仅对Flask程序的开发做一个简单的介绍，你可以阅读相关书籍了解更多细节，后面的程序实例不再详细介绍这个过程。</p><p>7.2.1 程序功能设计</p><p>规划和设计程序功能时，我们通常会使用思维导图工具或是清单工具。因为Say Hello非常简单，所以我打算创建一个非常简短的功能规格书，如下所示：</p><p>概述</p><p>Say Hello是一个类似于留言板的程序，用来让用户发表问候，对任何人任何事的问候。比如，用户A想问候这个世界，就可以在页面上发表一句“Hello, World!”。Say Hello的使用流程非常简单，我们甚至不需要画流程图。用户输入问候信息和姓名，按下提交按钮，就可以将问候加入到页面的消息列表中。</p><p>主页</p><p>主页是Say Hello唯一的页面，页面中包含创建留言的表单以及所有的问候消息。页面上方是程序的标题“Say Hello”，使用大字号和鲜艳的颜色。页面底部包含程序的版权标志、编写者、源码等相关信息。</p><p>问候表单</p><p>这个表单包含姓名和问候消息两个字段，其中姓名字段是普通的文本字段&lt;input type="text"&gt;，而消息字段是文本区域字段&lt;textarea&gt;&lt;/textarea&gt;。为了获得良好的样式效果，对这两个字段的输入值进行长度上的限制，姓名最长为20个字符，而问候消息最长为200个字符。</p><p>用户提交发布表单后：</p><p>1）如果验证出错，错误消息以红色小字的形式显示在字段下面；</p><p>2）如果通过验证，则在程序标题下面显示一个提示消息，用户可以通过消息右侧的按钮关闭提示。</p><p>问候消息列表</p><p>问候消息列表的上方显示所有消息的数量。每一条问候消息要包含的信息有发布者姓名、消息正文、发布的时间、消息的编号。消息发布时间要显示相对时间，比如“3分钟前”，当鼠标悬停在时间上时，弹出窗口显示具体的时间值。消息根据时间先后排序，最新发表的排在最上面。为了方便用户查询最早的消息，我们提供一个前往页面底部的按钮，同时提供一个回到页面顶部的按钮。</p><p>错误页面</p><p>错误页面包括404错误页面和500错误页面，和主页包含相同的部分——程序标题。程序标题下显示错误信息以及一个返回主页的“Go Back”链接。为了保持简单，错误页面不加入页脚信息。</p><p>7.2.2 前端页面开发</p><p>在前面列出的流程中，我们首先使用纸笔画草图，然后使用原型设计软件画出原型图，最后编写对应的HTML页面。根据程序的页面数量和复杂程度，你可以按需调整。因为Say Hello比较简单，我们直接使用原型工具画出原型图即可。</p><p>Say Hello的主页原型图如图7-1所示。</p><p>图7-1 主页原型图</p><p>附注</p><p>常用的原型设计工具有Axure RP（https://www.axure.com/）、Mockplus（https://www. mockplus.cn/）等。</p><p>错误页面原型图（404）如图7-2所示。</p><p>图7-2 404错误页面原型图</p><p>为了简化工作量，我们使用Bootstrap来编写页面样式。根据原型图编写的主页HTML页面如图7-3所示。</p><p>图7-3 主页HTML页面</p><p>根据原型图编写的错误页面HTML页面如图7-4所示。</p><p>图7-4 错误页面</p><p>在传统的Flask程序中，后端完成功能后会操作HTML代码，在其中添加Jinja2语句。比如，将页面中的临时URL替换为url_for()函数调用，把虚拟数据换成通过视图函数传入模板的变量，或是使用模板继承等技术组织这些HTML文件。我们会在7.2.3节中详细介绍。</p><p>7.2.3 后端程序开发</p><p>后端开发的相关知识我们在本书的第一部分已经介绍得差不多了，这里再进行一个快速回顾。</p><p>1．数据库建模</p><p>编写完功能规格书后，我们也就确定了需要使用哪些表来存储数据，表中需要创建哪些字段以及各个表之间的关系。对于复杂的数据库结构，你可以使用建模工具来辅助建立数据库关系。在Say Hello中，用于保存留言的Message模型如代码清单7-3所示。</p><p>代码清单7-3 sayhello.py：定义Message模型</p><p>from datetime import datetime         from sayhello import db         class Message(db.Model):             id = db.Column(db.Integer, primary_key=True)             body = db.Column(db.String(200))             name = db.Column(db.String(20))         timestamp = db.Column(db.DateTime, default=datetime.now, index=True)</p><p>timestamp字段用来存储每一条留言的发表时间（时间戳），这个字段存储Python的datetime对象。在这个字段中，我们将index设为True来开启索引，并使用default参数设置了字段默认值。</p><p>注意</p><p>timestamp字段的默认值是datetime.now而不是datetime.now()。前者是可调用的函数/方法对象（即名称），而后者是函数/方法调用（即动作）。SQLAlchemy会在创建新的数据库记录时（即用户提交表单实例化Message类时）调用该对象来设置默认值，这也是我们期待的效果。如果传入的不是方法对象，那么这个方法在加载模块时就会被执行，这将不是正确的时间戳。</p><p>为了方便在开发时重新创建数据库表，我们还添加了一个初始化数据库的initdb命令，和第5章介绍过的initdb()命令函数完全相同。</p><p>
2．创建表单类</p><p>问候表单由表单类Hello Form表示，表单中使用了文本区域字段Text Area Field，表示HTML中的&lt;textarea&gt;标签，如代码清单7-4所示。</p><p>代码清单7-4 forms.py：问候表单</p><p>from flask_wtf import FlaskForm         from wtforms import StringField, SubmitField, TextAreaField         from wtforms.validators import DataRequired, Length         class HelloForm(FlaskForm):             name = StringField('Name', validators=[DataRequired(), Length(1, 20)])             body = TextAreaField('Message', validators=[DataRequired(), Length(1, 200)])             submit = SubmitField()</p><p>3．编写视图函数</p><p>错误处理函数比较简单，我们重点介绍一下index视图。index视图有两个作用：</p><p>1）处理GET请求，从数据库中查询所有的消息记录，返回渲染后的包含消息列表的主页模板index.html。</p><p>2）处理POST请求，问候表单提交后，验证表单数据，通过验证后将数据保存到数据库中，使用flash()函数显示一条提示，然后重定向到index视图，渲染页面。</p><p>具体示例如代码清单7-5所示。</p><p>代码清单7-5 sayhello/views.py：index视图</p><p>from flask import flash, redirect, url_for, render_template         from sayhello import app, db         from sayhello.models import Message         from sayhello.forms import HelloForm         @app.route('/', methods=['GET', 'POST'])         def index():             # 加载所有的记录             messages = Message.query.order_by(Message.timestamp.desc()).all()             form = HelloForm()             if form.validate_on_submit():                 name = form.name.data                 body = form.body.data                 message = Message(body=body, name=name)  # 实例化模型类，创建记录                 db.session.add(message)  # 添加记录到数据库会话                 db.session.commit()  # 提交会话                 flash('Your message have been sent to the world! ')                 return redirect(url_for('index'))  # 重定向到index视图             return render_template('index.html', form=form, messages=messages)</p><p>在获取message记录时，我们使用order_by()过滤器对数据库记录进行排序，参数是排序的规则。我们根据Message模型的timestamp字段值排序，字段上附加的排序方法为desc()，代表降序（descending），同样还有一个asc()方法表示升序（ascending）。</p><p>

4．编写模板</p><p>我们将index.html和404.html，以及500.html中的共有部分抽出合并为基模板base.html。基模板包含一个完整的HTML结构，我们在其中创建了几个块：title、content和footer，如代码清单7-6所示。

</p><p>代码清单7-6 templates/base.html：基模板</p><p>&lt;! DOCTYPE html&gt;         &lt;html lang="en"&gt;         &lt;head&gt;             &lt;meta charset="utf-8"&gt;             &lt;meta  name="viewport"  content="width=device-width,  initial-scale=1,  shrink-                 to-fit=no"&gt;             &lt;title&gt;{% block title %}Say Hello! {% endblock %}&lt;/title&gt;             &lt;link rel="icon" href="{{ url_for('static', filename='favicon.ico') }}"&gt;             &lt;link  rel="stylesheet"  href="{{  url_for('static',  filename='css/bootstrap.                 min.css') }}" type="text/css"&gt;             &lt;link  rel="stylesheet"  href="{{  url_for('static',  filename='css/style.css')                 }}" type="text/css"&gt;         &lt;/head&gt;         &lt;body&gt;         &lt;main class="container"&gt;             &lt;header&gt;                 &lt;h1 class="text-center display-4"&gt;                     &lt;a href="{{  url_for('index')  }}"  class="text-success"&gt;&lt;strong&gt;Say                         Hello&lt;/strong&gt;&lt;/a&gt;                     &lt;small  style="font-size:  24px"  class="text-muted"&gt;to  the  world&lt;/                         small&gt;                 &lt;/h1&gt;             &lt;/header&gt;             {% for message in get_flashed_messages() %}             &lt;div class="alert alert-info"&gt;                 &lt;button type="button" class="close" data-dismiss="alert"&gt;. &lt;/button&gt;                 {{ message }}             &lt;/div&gt;             {% endfor %}             {% block content %}{% endblock %}             &lt;footer class="text-center"&gt;                 {% block footer %}                   .                 &lt;p&gt;&lt;a id="bottom" href="#" title="Go Top"&gt;↑ &lt;/a&gt;&lt;/p&gt;                 {% endblock %}             &lt;/footer&gt;         &lt;/main&gt;         &lt;script  type="text/javascript"  src="{{  url_for('static',  filename='js/jquery-             3.2.1.slim.min.js') }}"&gt;&lt;/script&gt;         &lt;script type="text/javascript" src="{{ url_for('static', filename='js/popper.min.             js') }}"&gt;&lt;/script&gt;         &lt;script type="text/javascript" src="{{ url_for('static', filename='js/bootstrap.             min.js') }}"&gt;&lt;/script&gt;         &lt;script type="text/javascript" src="{{ url_for('static', filename='js/script.js')             }}"&gt;&lt;/script&gt;         &lt;/body&gt;         &lt;/html&gt;</p><p>

在head标签和body标签内，我们引入了Bootstrap所需的CSS和Java Script文件，以及Bootstrap所依赖的j Query和Popper.js。另外，我们还引入了自定义的style.css和script.js文件，这两个文件分别用来存储自定义的CSS样式定义和Java Script代码。</p><p>附注</p><p>这里为消息应用了Bootstrap提供的alert-info样式（蓝色背景），后面我们会学习对flash消息添加分类，以便对不同类别的消息应用不同的样式。</p><p>在主页模板index.html中，我们使用form_field()宏渲染表单，然后迭代传入的messages变量，渲染消息列表，如代码清单7-7所示。</p><p>代码清单7-7


 index.html：渲染表单和留言列表</p><p>
{% extends 'base.html' %}         
{% from 'macros.html' import form_field %}         
{% block content %}         &lt;div class="hello-form"&gt;             &lt;form method="post" action="{{request.full_path}}"&gt;                 {{ form.csrf_token }}                 &lt;div class="form-group required"&gt;                     {{ form_field(form.name, class='form-control') }}                 &lt;/div&gt;                 &lt;div class="form-group required"&gt;                     
{{ form_field(form.body, class='form-control') }}                 &lt;/div&gt;                 
{{ form.submit(class='btn btn-secondary') }}             &lt;/form&gt;         &lt;/div&gt;         &lt;h5&gt;{{ messages|length }} messages             &lt;small class="float-right"&gt;                 &lt;a href="#bottom" title="Go Bottom"&gt;↓ &lt;/a&gt;             &lt;/small&gt;         &lt;/h5&gt;         &lt;div class="list-group"&gt;             {% for message in messages %}                 &lt;a class="list-group-item list-group-item-action flex-column"&gt;                     &lt;div class="d-flex w-100 justify-content-between"&gt;                         &lt;h5 class="mb-1 text-success"&gt;{{ message.name }}                             &lt;small class="text-muted"&gt; #{{ loop.revindex }}&lt;/small&gt;                         &lt;/h5&gt;                         &lt;small&gt;                             {{ message.timestamp.strftime('%Y/%m/%d %H:%M') }}                         &lt;/small&gt;                     &lt;/div&gt;                     &lt;p class="mb-1"&gt;{{ message.body }}&lt;/p&gt;                 &lt;/a&gt;             {% endfor %}         &lt;/div&gt;         {% endblock %}</p><p>提示</p><p>

我们曾在第4章介绍过，表单默认提交到当前URL。如果用户单击了向下按钮，会在URL中添加URL片段，比如“#bottom”，它指向页面底部的a元素（其id值为bottom），所以会跳转到页面底部（关于URL片段我们会在第8章详细了解）。当表单被提交后，页面加载时仍会跳转到URL片段对应的位置，为了避免这个行为，可以显式地使用action属性指定表单提交的目标URL，使用request.full_path获取没有URL片段的当前请求URL。</p><p>

渲染时间戳时，我们使用datetime.strftime()方法将时间戳输出格式定义为：“年/月/日时：分”，这显然不是我们设计功能时想要的时间，在后面我们借助其他工具来获取相对时间并显示绝对时间弹窗。除了时间戳外，我们还渲染了loop.revindex变量，用来表示留言的反向序号标记。</p><p>7.3 

使用Bootstrap-Flask简化页面编写</p><p>扩展Bootstrap-Flask内置了可以快速渲染Bootstrap样式HTML组件的宏，并提供了内置的Bootstrap资源，方便快速开发，使用它可以简化在Web程序里集使用Bootstrap的过程。</p><p>提示</p><p>扩展Bootstrap-Flask基于扩展Flask-Bootstrap（https://github.com/mbr/flask-bootstrap）实现，旨在替代缺乏维护的后者。和Flask-Bootstrap相比，Bootstrap-Flask简化了大部分功能（比如未内置基模板），添加了Bootstrap4支持，并增加了一些辅助功能。</p><p>提示</p><p>如果你从Git Hub上复制了示例程序，可以执行git checkout bootstrap签出程序的新版本。</p><p>首先使用Pipenv安装Bootstrap-Flask：</p><p>$ pipenv install bootstrap-flask</p><p>需要注意，Bootstrap-Flask提供的包名称为flask_bootstrap，我们从这个包导入并实例化Bootstrap类，传入程序实例app，以完成扩展的初始化：</p><p>from flask import Flask         from flask_bootstrap import Bootstrap         app = Flask(__name__)         bootstrap = Bootstrap(app)</p><p>7.3.1 加载资源文件</p><p>Bootstrap-Flask在模板中提供了一个bootstrap对象，这个对象提供了两个方法可以用来生成资源引用代码：用来加载CSS文件的bootstrap.load_css()方法和用来加载Java Script文件（包括Bootstrap、j Query、Popper.js）的bootstrap.load_js()方法。Flask-Bootstrap默认从CDN（Content Delivery Network，内容分发网络）加载Bootstrap资源，同时也提供了内置的本地资源。如果你想使用Bootstrap-Flask提供的本地资源，可以将配置变量BOOTSTRAP_SERVE_LOCAL设为True。另外，当FLASK_ENV环境变量设为development时，Bootstrap-Flask将自动使用本地资源。</p><p>提示</p><p>尽管使用这些方法非常方便，但我们最好在开发时自己手动管理本地静态资源。

Say Hello的static目录下包含了所有需要的资源文件，基模板中的资源文件都从static文件夹中引入。</p><p>如果你想使用Bootstrap-Flask提供的方法加载资源，那么只需要在相应的位置分别调用资源加载方法，替换掉这些对应的资源加载语句即可：</p><p>&lt;head&gt;             {{ bootstrap.load_css() }}         &lt;/head&gt;         &lt;body&gt;               .             {{ bootstrap.load_js() }}         &lt;/body&gt;</p><p>另外，在bootstrap_load_js()方法中，使用with_jquery和with_popper可以设置是否加载j Query和Popper.js的Java Script资源，默认为True，设为False可以关闭。</p><p>7.3.2 快捷渲染表单</p><p>Bootstrap-Flask内置了两个用于渲染WTForms表单类的宏，一个是与我们第4章创建的form_field宏类似的render_field()宏，另一个是用来快速渲染整个表单的render_form()宏。这两个宏都会自动渲染错误消息，渲染表单的验证状态样式。</p><p>Bootstrap-Flask提供的表单渲染宏通过其内置的bootstrap/form.html模板导入，render_field()宏的使用方式和我们自己编写的form_field()宏完全相同。值得特别介绍的是render_form()宏，它使用起来更加简单，使用一行代码就可以渲染整个表单，而且会自动帮我们渲染CSRF令牌字段form.csrf_token。下面使用这个宏在index.html模板中渲染问候表单：</p><p>{% extends 'base.html' %}         {% from 'bootstrap/form.html' import render_form %}         {% block content %}             &lt;div class="hello-form"&gt;                 {{ render_form(form), action=request.full_path}}             &lt;/div&gt;         {% endblock %}</p><p>它将会自动为你创建一个&lt;form&gt;标签，然后在标签内依次渲染包括CSRF令牌在内的所有字段。除了渲染表单字段，它还会根据表单的验证状态来渲染表单状态和错误消息。一般情况下，你只需要传入表单类实例作为参数。除此之外，quick_form()宏还支持许多参数来自定义表单，常用的参数及说明如表7-2所示。</p><p>表7-2 render_form()宏常用参数</p><p>包括用来渲染表单的render_field()和render_form()宏在内，Bootstrap-Flask还提供了许多其他用途的宏，这些宏都可以通过bootstrap目录下的模板导入，具体用法我们会在后面介绍。常用的Bootstrap-Flask宏如表7-3所示。




</p><p>表7-3 Bootstrap-Flask内置的常用宏</p><p>附注</p><p>完整的可用宏列表请访问Bootstrap-Flask文档的宏页面（https://bootstrap-flask.readthedocs. io/en/latest/macros.html）查看。</p><p>7.4 使用Flask-Moment本地化日期和时间</p><p>在Message类中，我们存储时间戳时使用的是datetime模块的datetime.now()方法生成的datetime对象，它是一个本地时间。具体来说，这个方法会返回服务器（也就是运行程序的计算机）设置的时区所对应的时间。对于测试来说这足够了，但如果我要把程序部署到真正的服务器上，就可能会面临时区问题。比如，我把程序部署到美国的服务器上，那么这个时间将不再是我们期待的东八区时间，而是服务器本地的美国时间。另一方面，如果我们的程序被其他时区的人访问，他们更希望看到自己所在时区的时间，而不是固定的东八区时间。</p><p>提示</p><p>如果你从Git Hub上复制了示例程序，可以执行git checkout moment签出程序的新版本。</p><p>7.4.1 本地化前的准备</p><p>如何让世界各地的用户访问程序时都能看到自己的本地时间呢？一个简单的方法是使用Java Script库在客户端（浏览器）中进行时间的转换，因为浏览器可以获取到用户浏览器/电脑上的时区设置信息。</p><p>为了能够在客户端进行时间的转换，我们需要在服务器端提供纯正的时间（naive time），即不包含时区信息的时间戳（与之相对，包含时区的时间戳被称为细致的时间，即aware time）。datetime模块的datetime.utcnow()方法用来生成当前的UTC（Coordinated Universal Time，协调世界时间），而UTC格式时间就是不包含时区信息的纯正时间。我们将使用它在时间戳字段上替代之前的datetime.now方法，作为时间戳timestamp字段的默认值：</p><p>from datetime import datetime         ...         class Message(db.Model):             ...             timestamp = db.Column(db.DateTime, default=datetime.utcnow)</p><p>7.4.2 使用Flask-Moment集成Moment.js</p><p>Moment.js（https://momentjs.com/）是一个用于处理时间和日期的开源Java Script库，它可以对时间和日期进行各种方式的处理。它会根据用户电脑中的时区设置在客户端使用Java Script来渲染时间和日期，另外它还提供了丰富的时间渲染格式支持。</p><p>扩展Flask-Moment简化了在Flask项目中使用Moment.js的过程，集成了常用的时间和日期处理函数。首先使用Pipenv安装：</p><p>$ pipenv install flask-moment</p><p>然后我们实例化扩展提供的Moment类，并传入程序实例app，以完成扩展的初始化：</p><p>
from flask_moment import Moment         
app = Flask(__name__)         ...         
moment = Moment(app)


</p><p>为了使用Moment.js，我们需要在基模板中加载Moment.js资源。Flask-Moment在模板中提供了moment对象，这个对象提供两个方法来加载资源：moment.include_moment()方法用来加载Moment.js的Javascript资源；moment.include_jquery()用来加载j Query。这两个方法默认从CDN加载资源，传入local_js参数可以指定本地资源URL。</p><p>提示</p><p>我们在使用Bootstrap时已经加载了j Query，这里只需要加载Moment.js的Java Script文件。</p><p>基于同样的理由，我们将在程序中手动加载资源。首先访问Moment.js官网（https://momentjs.com/）下载相应的资源文件到static文件夹，然后在基模板中引入。因为moment. include_moment()会用来生成执行时间渲染的JavaScript函数，所以我们必须调用它，可以通过local_js参数传入本地资源的URL，如果不传入这个参数则会从CDN加载资源：</p><p>...         {{ moment.include_moment(local_js=url_for('static',  filename='js/moment-with-             locales.min.js')) }}         &lt;/body&gt;</p><p>注意</p><p>Moment.js官网提供的文件中moment.min.js仅包含英文语言的时间日期字符，如果要使用其他语言，需要下载moment-with-locales.min.js。</p><p>Flask-Moment默认以英文显示时间，我们可以传入区域字符串到locale ()方法来更改显示语言，下面将语言设为简体中文：</p><p>...         {{ moment.locale('zh-cn') }}         &lt;/body&gt;</p><p>附注</p><p>在Moment.js中，简体中文的地区字符串为“zh-cn”，中国香港繁体中文和中国台湾繁体中文，则分别使用为“zh-hk”和“zh-tw”。</p><p>除了使用locale参数固定地区，更合理的方式是根据用户浏览器或计算机的语言来设置语言，我们可以在locale()方法中将auto_detect参数设为True，这会自动探测客户端语言设置并选择合适的区域设置：</p><p>...         {{ moment.locale(auto_detect=True) }}         &lt;/body&gt;</p><p>7.4.3 渲染时间日期</p><p>Moment.js提供了非常丰富、灵活的时间日期格式化方式。在模板中，我们可以通过对moment类调用format()方法来格式化时间和日期，moment的构造方法接收使用utcnow()方法创建的datetime对象作为参数，即Message对象的timestamp属性。format()方法接收特定的格式字符串来渲染时间格式，比如：</p><p>{{ moment(timestamp).format(’格式字符串’) }}</p><p>提示</p><p>时间日期会在页面加载完成后执行Java Script函数使用Moment.js渲染，所以时间日期的显示会有微小的延迟。</p><p>Moment.js提供了一些内置的格式字符串，字符串及对应的中文输出示例如表7-4所示。</p><p>表7-4 Moment.js内置格式化字符串</p><p>提示</p><p>我们也可以通过Moment.js支持的时间单位参数自定义时间输出，比如使用格式字符串“YYYYMMMMDo ， ah:mm:ss”将会得到输出：2017七月26日，早上8:00:00。完整的参数及输出列表可以在这里看到：https://momentjs.com/docs/displaying/format/。</p><p>除了输出普通的时间日期，Moments.js还支持输出相对时间。比如相对于当前时间的“三分钟前”“一个月前”等。这通过from Now()方法实现，在新版本的Say Hello中，时间戳就使用这个函数渲染：</p><p>&lt;small&gt;{{ moment(message.timestamp).fromNow(refresh=True) }}&lt;/small&gt;</p><p>将refresh参数设为True（默认为False）可以让时间戳在不重载页面的情况下，随着时间的变化自动刷新。如果你在页面上等待一会儿，就会看到时间戳从“几秒前”变成了“1分钟前”。</p><p>附注</p><p>Flask-Moment实现了Moment.js的format()、from Now()、from Time()、calendar()、valueof()和unix()方法，具体的使用方法参见Moment.js文档（https://momentjs.com/docs/）。</p><p>有些时候，使用Flask-Moment提供的方法还不够灵活，这时可以手动使用Moment.js渲染时间日期。比如，当鼠标悬停在问候消息的时间日期上时，我们希望能够显示一个包含具体的绝对时间的弹出窗口（tooltip）。</p><p>为了能够在Java Script中使用Moment.js渲染时间日期，我们需要在显示相对时间的HTML元素中创建一个data-timestamp属性存储原始的时间戳，以便在Java Script中获取：</p><p>&lt;small data-toggle="tooltip" data-placement="top" data-delay="500"         data-timestamp="{{ message.timestamp.strftime('%Y-%m-%dT%H:%M:%SZ') }}"&gt;             {{ moment(message.timestamp).fromNow(refresh=True) }}         &lt;/small&gt;</p><p>注意</p><p>为了让时间戳能够正常被Moment.js解析，我们需要使用strftime()方法对原始的时间字符串按照ISO 8601标准进行格式化处理。</p><p>我们在script.js脚本存储Java Script代码，下面的Java Script代码将时间日期对应元素的tooltip内容设置为渲染后的时间日期：</p><p>$(function () {             function render_time() {                 return moment($(this).data('timestamp')).format('lll')             }             $('[data-toggle="tooltip"]').tooltip(                 {title: render_time}             );         });</p><p>在Bootstrap中，Tooltip组件需要调用tooltip()方法进行初始化。我们使用data-toggle属性作为选择器选择所有设置了tooltip的元素，对其调用tooltip()方法。在调用这个方法时，可以传入一些选项，如title选项用来设置弹出的内容，可以是字符串也可以是函数对象。</p><p>在渲染时间日期的render_time()函数中，渲染时间日期使用的moment()函数是由Moment. js提供的，而不是Flask-Moment传入模板的类。$(this).data('timestamp')获取了对应元素的data-timestamp属性值，特殊变量this表示当前触发事件的元素对象。现在，当鼠标悬停在时间戳上时，会弹出包含具体时间的小窗口，如图7-5所示。</p><p>图7-5 包含具体时间的弹窗</p><p>附注</p><p>在Bootstrap中，Popover和Tooltip组件依赖于Java Script包Popper.js（https://popper. js.org/），要使用这两个组件，需确保在基模板中加载了对应的Java Script文件。作为替代，你也可以加载Bootstrap提供的合集包文件bootstrap.bundle.min.css。</p><p>7.5 使用Faker生成虚拟数据</p><p>创建虚拟数据是编写Web程序时的常见需求。在简单的场景下，我们可以手动创建一些虚拟数据，但更方便的选择是使用第三方库实现。流行的Python虚拟数据生成工具有Mimesis （https://github.com/lk-geimfari/mimesis）和Faker，后者同时支持Python2和Python3，而且文档中包含丰富的示例，所以这里将选用Faker。首先使用Pipenv安装（使用--dev选项声明为开发依赖）：</p><p>$ pipenv install faker --dev</p><p>Faker内置了20多类虚拟数据，包括姓名、地址、网络账号、信用卡、时间、职位、公司名称、Python数据等。要生成虚拟数据，首先要实例化Faker类，创建一个fake对象作为虚拟数据生成器：</p><p>&gt;&gt;&gt; from faker import Faker         &gt;&gt;&gt; fake = Faker()</p><p>这个fake对象可以使用分别对应所有虚拟数据类别的方法来获取虚拟数据，比如name、address、text等。每次调用都会获得不同的随机结果，一些基本示例如下所示：</p><p>&gt;&gt;&gt; from faker import Faker         &gt;&gt;&gt; fake = Faker()         &gt;&gt;&gt; fake.name()         'Lucy Cechtelar'         &gt;&gt;&gt; fake.address()         426 Jordy Lodge         Cartwrightshire, SC 88120-6700"         &gt;&gt;&gt; fake.text()         Sint velit eveniet. Rerum atque repellat voluptatem quia rerum. Numquam excepturi         beatae sint laudantium consequatur. Magni occaecati itaque sint et sit tempore.         Nesciunt.</p><p>提示</p><p>你可以访问Faker官方文档的Providers一章（http://faker.readthedocs.io/en/master/providers.html）查看所有分类下可用的虚拟数据方法。</p><p>默认的虚拟数据语言为英文，如果你想获取其他语言的虚拟数据，可以在实例化Faker类时传入区域字符作为第一个参数（locale）来指定：</p><p>fake = Faker('zh_CN'))</p><p>提示</p><p>在Faker中，简体中文和繁体中文对应的区域字符串分别为zh_CN和zh_TW。</p><p>在代码清单7-8中，我们使用Faker实现了一个生成虚拟留言数据的命令函数fake。</p><p>代码清单7-8 sayhello/commands.py：生成虚拟留言的命令</p><p>import click         from sayhello import app         ...         @app.cli.command()         @click.option('--count', default=20, help='Quantity of messages, default is 20.')         def forge(count):             """Generate fake messages."""             from faker import Faker             db.drop_all()             db.create_all()             fake = Faker()  # 创建用来生成虚拟数据的Faker实例             click.echo('Working...')             for i in range(count):                 message = Message(                     name=fake.name(),                     body=fake.sentence(),                     timestamp=fake.date_time_this_year()                 )                 db.session.add(message)             db.session.commit()             click.echo('Created %d fake messages.' % count)</p><p>提示</p><p>使用for循环操作数据库时，为了提高效率，我们只需要在for循环结束后调用一次db.session.commit()方法提交数据库会话。</p><p>在这个命令函数前，我们使用click提供的option装饰器为命令添加数量选项--count，使用default关键字将默认值设为20。</p><p>为了方便测试，生成虚拟数据前会删除重建数据库表。我们分别调用fake对象的name()、sentence()、date_time_this_year()方法生成虚拟的姓名、留言和时间戳。现在使用下面的命令生成虚拟数据：</p><p>$ flask forge         Working...             Created 20 fake messages.</p><p>选项--count用来指定生成的留言数量，下面生成了50条虚拟留言：</p><p>$ flask forge --count=50         Working...             Created 50 fake messages.</p><p>现在运行程序，首页会显示一个很长的留言列表，根据创建的随机日期排序，最先发表的排在上面，如图7-6所示。</p><p>图7-6 虚拟留言列表</p><p>7.6 使用Flask-Debug Toolbar调试程序</p><p>扩展Flask-Debug Toolbar提供了一系列调试功能，可以用来查看请求的SQL语句、配置选项、资源加载情况等信息。这些信息在开发时会非常有用。首先使用Pipenv安装Flask-Debug Toolbar及其依赖：</p><p>$ pipenv install flask-debugtoolbar</p><p>然后实例化扩展提供的Debug Toolbar Extension类，传入程序实例app，以完成扩展的初始化：</p><p>from flask import Flask         ...         from flask_debugtoolbar import DebugToolbarExtension         app = Flask(__name__)         ...         toolbar = DebugToolbarExtension(app)</p><p>开发时不需要也不建议使用Flask-Debug Toolbar。Flask-Debug Toolbar只在开启了调试模式时才会启动，所以我们要确保设置正确的FLASK_ENV环境变量值：开发时设为development；部署时则设为production。另外，Flask-Debug Toolbar会拦截重定向请求，将DEBUG_TB_INTERCEPT_REDIRECTS配置变量设为False可以关闭这个特性：</p><p>DEBUG_TB_INTERCEPT_REDIRECTS = False</p><p>这时启动程序，就会发现页面右侧多了一个工具栏，单击“Hide”按钮可以隐藏为一个浮动按钮，如图7-7所示。</p><p>图7-7 开启调试工具栏后的界面</p><p>提示</p><p>在Say Hello的实际代码中并没有使用Flask-Debug Toolbar，这里只是演示。</p><p>在调试工具栏中，除了Flask版本以及页面的加载时间信息，右侧的功能选项分别为：HTTP首部、请求相关变量、配置变量、模板渲染记录、数据库查询记录、日志、路由列表、性能分析器。在第13章，我们会借助它来对Flask程序进行性能分析。图7-8显示了当前程序中的所有配置选项。</p><p>图7-8 使用调试工具栏查看程序配置</p><p>7.7 Flask配置的两种组织形式</p><p>在Flask中，开发和部署时通常需要不同的配置。比如，存储在SECRET_KEY配置变量的密钥，在开发时可以使用占位字符，但在生产环境下部署时则需要使用一个随机生成的字符串。为了区分，我们通常会有两种组织这种分离的方式。本书的示例程序均使用第一种方式，你可以自由选择。</p><p>7.7.1 环境变量优先</p><p>12-Factor程序第三条（https://www.12factor.net/zh_cn/config）建议通过环境变量来保存配置，以便将配置和程序分离开来，并且对不同场景下的配置进行分离。在第8章，我们将介绍如何通过Python类来组织不同场景下的配置变量。而从本书一开始，我们就创建了.env和.flaskenv来存储环境变量，对于包含敏感信息的配置，我们优先或仅从环境变量中读取，这些环境变量统一在.env文件中定义，从而实现了敏感配置的分离。因为我们在.gitignore中添加了这个文件，所以不会被提交进Git仓库。</p><p>7.7.2 实例文件夹覆盖</p><p>尽管在示例程序中并没有使用这个特性，但我们还是有必要介绍一下Flask中的实例文件夹（instance folder）。为了方便存储开发和部署时的各类文件，Flask提供了实例文件夹支持。你可以在项目根目录（程序包旁）中创建一个名称为instance的文件夹，在这个文件夹中存储开发或部署时使用的配置文件，包含敏感信息的文件，或是临时创建的数据库文件等。</p><p>注意</p><p>记得将这个实例文件夹加入.gitignore文件中，以确保不会提交到Git仓库中。</p><p>当使用实例文件夹存储配置时，一个方便的做法是把包含敏感数据的配置放到instance文件夹的配置文件中，外部只保留通用的公开配置。Flask允许加载多次配置，重复的配置以最后定义的配置为准，所以我们可以使用instance文件夹中的配置来覆盖通用配置：</p><p>app = Flask(__name__, instance_relative_config=True)         app.config.from_object('config')  # 通用配置         app.config.from_pyfile('config.py')  # instance文件夹下的配置</p><p>在创建程序实例时，我们将instance_relative_config参数True，这会告诉Flask我们的配置文件路径是相对于实例文件夹的（默认是相对于程序实例根目录的）。</p><p>临时的数据库文件也可以放到实例文件夹中，实例文件夹的路径可以通过app.instance_path属性获取，所以你可以使用下面的方法构建数据库URI：</p><p>SQLALCHEMY_DATABASE_URI = 'sqlite:///' + os.path.join(app.instance_path, 'data.             db')</p><p>Flask不会自动创建实例文件夹，所以你需要手动创建。在单脚本程序中，实例文件夹在脚本旁创建；在使用程序包的程序中，实例文件夹在程序包旁创建。</p><p>提示</p><p>当我们使用flask shell命令时，输出的信息会给出实例文件夹的合适位置。</p><p>7.8 本章小结</p><p>本章基于Say Hello程序的编写复习了本书第一部分介绍的基础知识，并且介绍了基本的项目组织方法以及Web程序的基本开发流程。对于更大的项目，我们后面会学习使用工厂函数、蓝本等技术进一步组织项目。</p><p>附注</p><p>如果你发现了Say Hello程序中的错误或者有改进建议，可以在Say Hello的Git Hub项目（https://github.com/greyli/sayhello）中创建Issue，或是在fork仓库修改后并在Git Hub上提交Pull Request。</p></div><div class="verticalReader_chapter_bottom"><a role="button" href="javascript:;" class="wr_btn wr_btn_Big wr_btn_Gray">下一章</a> <a role="button" href="javascript:" class="wr_btn wr_btn_Big wr_btn_Gray"><span>下载微信读书免费阅读</span></a><!----></div><!----></div></div><div><section class="wr_bottomEntry wr_bottomEntry_WithIcon wr_tabBar_list verticalReader_bottomEntry verticalReader_bottomEntry_Show"><a class="wr_bottomEntry_link bookstore_bottomEntry_link wr_tabBar_item wr_tabBar_item_Catalog"><span class="wr_bottomEntry_link_icon"></span><span class="wr_bottomEntry_link_title">目录</span></a><a class="wr_bottomEntry_link wr_tabBar_item wr_tabBar_item_BookshelfRemove"><span class="wr_bottomEntry_link_icon"></span><!----><span class="wr_bottomEntry_link_title">已加入书架</span></a><a class="wr_bottomEntry_link bookstore_bottomEntry_link wr_tabBar_item wr_tabBar_item_WeRead" href="/wrpage//wechat/search/store"><span class="wr_bottomEntry_link_icon"></span><span class="wr_bottomEntry_link_title">更多免费小说</span></a></section><div class=""><div class="wr_mask"><!----></div><div class="wr_alert"><div class="wr_alert_cnt"><p class="wr_alert_title">               本书已加入书架           </p> <p class="wr_alert_text">               你将接收到本书的更新通知，并可以随时从书架阅读           </p></div> <div class="wr_alert_buttons wr_alert_buttons_Stack"><a href="javascript:;" class="wr_alert_buttons_item wr_alert_buttons_item_Delete">将本书移除出书架</a><a href="javascript:;" class="wr_alert_buttons_item">查看我的书架</a><a href="javascript:;" class="wr_alert_buttons_item">取 消</a></div></div></div></div><a href="javascript:;" class="verticalReader_promotionTip verticalReader_promotionTip_Show"><span class="verticalReader_promotionTip_icon"></span><div class="verticalReader_promotionTip_cnt"><div class="verticalReader_promotionTip_title">免费领取此书</div><div class="verticalReader_promotionTip_desc">下载微信读书App</div></div></a><!----><div class=""><div class="wr_mask"><span class="wr_mask_closeBtn"></span></div><div class="wr_alert wr_alert_ForCloseBtn wr_alert_Slide"><div class="wr_buyBookView"><div><div class="wr_buyBookView_money">89</div><div class="wr_buyBookView_balance">余额 </div><div class="wr_buyBookView_info"><div class="wr_buyBookView_info_title">书籍</div><div class="wr_buyBookView_info_detail">Flask Web开发实战：入门、进阶与原理解析</div></div><div class="wr_buyBookView_info"><div class="wr_buyBookView_info_title">作者</div><div class="wr_buyBookView_info_detail">李辉</div></div></div><div class="wr_bottomEntry wr_buyBookView_action"><a title="充值" href="http://pay.qq.com/h5/open_qqbook.shtml?plat=0&amp;pf=wx.dushu.search&amp;mmticket=MM_4387884268643865_1_0303865520029523_PB" class="wr_bottomEntry_link wr_bottomEntry_link_Blue">充 值</a></div></div> <!----></div></div><div class=""><div class="wr_mask"><!----></div><div class="wr_alert"><div class="wr_alert_cnt"><p class="wr_alert_title">               是否关闭自动购买？           </p> <p class="wr_alert_text">               关闭后，阅读到本书未购买章节均需手动购买确认。           </p></div> <div class="wr_alert_buttons"><a href="javascript:;" class="wr_alert_buttons_item">取 消</a><a href="javascript:;" class="wr_alert_buttons_item">关 闭</a></div></div></div><div class=""><div class="wr_mask"><!----></div><div class="wr_alert"><div class="wr_alert_cnt"><p class="wr_alert_title">               已成功加入书架           </p> <p class="wr_alert_text">               已成功加入书架，下载微信读书即可查看，新用户还可免费领取三本书哦。           </p></div> <div class="wr_alert_buttons"><a href="javascript:;" class="wr_alert_buttons_item">我知道了</a></div></div></div><div class="wr_mask verticalReader_catalogMask"></div><div class="verticalReader_catalog"><div class="verticalReader_catalog_head"><div class="verticalReader_catalog_head_top"><a href="javascript:;" class="wr_bookCover wr_bookCover_Book40" alt="Flask Web开发实战：入门、进阶与原理解析"><!----><!----><img alt="书籍封面" class="wr_bookCover_img" src="https://wfqqreader-1252317822.image.myqcloud.com/cover/517/22987517/t1_22987517.jpg"><span class="wr_bookCover_gradientDecor"></span></a><div class="verticalReader_catalog_head_info"><p class="verticalReader_catalog_head_info_title">Flask Web开发实战：入门、进阶与原理解析</p><p class="verticalReader_catalog_head_info_author">李辉</p></div><a href="javascript:" class="verticalReader_catalog_head_sort"><span class="verticalReader_catalog_head_sort_icon"></span> <span class="verticalReader_catalog_head_sort_text">倒序</span></a></div><!----></div><ul class="verticalReader_catalog_list js_catalog_list" id="catalogList"><!----><li id="catalog_item_3" class="verticalReader_catalog_item"><a href="javascript:;" class="verticalReader_catalog_link"><!----> <span class="verticalReader_catalog_item_text">前言</span></a></li><li id="catalog_item_4" class="verticalReader_catalog_item"><a href="javascript:;" class="verticalReader_catalog_link"><!----> <span class="verticalReader_catalog_item_text">第一部分 基础篇</span></a></li><li id="catalog_item_5" class="verticalReader_catalog_item"><a href="javascript:;" class="verticalReader_catalog_link"><!----> <span class="verticalReader_catalog_item_text">第1章 初识Flask</span></a></li><li id="catalog_item_6" class="verticalReader_catalog_item"><a href="javascript:;" class="verticalReader_catalog_link"><!----> <span class="verticalReader_catalog_item_text">第2章 Flask与HTTP</span></a></li><li id="catalog_item_7" class="verticalReader_catalog_item"><a href="javascript:;" class="verticalReader_catalog_link"><!----> <span class="verticalReader_catalog_item_text">第3章 模板</span></a></li><li id="catalog_item_8" class="verticalReader_catalog_item"><a href="javascript:;" class="verticalReader_catalog_link"><!----> <span class="verticalReader_catalog_item_text">第4章 表单</span></a></li><li id="catalog_item_9" class="verticalReader_catalog_item"><a href="javascript:;" class="verticalReader_catalog_link"><!----> <span class="verticalReader_catalog_item_text">第5章 数据库</span></a></li><li id="catalog_item_10" class="verticalReader_catalog_item"><a href="javascript:;" class="verticalReader_catalog_link"><!----> <span class="verticalReader_catalog_item_text">第6章 电子邮件</span></a></li><li id="catalog_item_11" class="verticalReader_catalog_item"><a href="javascript:;" class="verticalReader_catalog_link"><!----> <span class="verticalReader_catalog_item_text">第二部分 实战篇</span></a></li><li id="catalog_item_12" class="verticalReader_catalog_item verticalReader_catalog_item_Current"><a href="javascript:;" class="verticalReader_catalog_link"><!----> <span class="verticalReader_catalog_item_text">第7章 留言板</span></a></li><li id="catalog_item_13" class="verticalReader_catalog_item"><a href="javascript:;" class="verticalReader_catalog_link"><!----> <span class="verticalReader_catalog_item_text">第8章 个人博客</span></a></li><li disabled="disabled" id="catalog_item_14" class="verticalReader_catalog_item"><a href="javascript:;" class="verticalReader_catalog_link"><span class="verticalReader_catalog_item_lock"></span> <span class="verticalReader_catalog_item_text">第9章 图片社交网站</span></a></li><li disabled="disabled" id="catalog_item_15" class="verticalReader_catalog_item"><a href="javascript:;" class="verticalReader_catalog_link"><span class="verticalReader_catalog_item_lock"></span> <span class="verticalReader_catalog_item_text">第10章 待办事项程序</span></a></li><li disabled="disabled" id="catalog_item_16" class="verticalReader_catalog_item"><a href="javascript:;" class="verticalReader_catalog_link"><span class="verticalReader_catalog_item_lock"></span> <span class="verticalReader_catalog_item_text">第11章 在线聊天室</span></a></li><li disabled="disabled" id="catalog_item_17" class="verticalReader_catalog_item"><a href="javascript:;" class="verticalReader_catalog_link"><span class="verticalReader_catalog_item_lock"></span> <span class="verticalReader_catalog_item_text">第三部分 进阶篇</span></a></li><li disabled="disabled" id="catalog_item_18" class="verticalReader_catalog_item"><a href="javascript:;" class="verticalReader_catalog_link"><span class="verticalReader_catalog_item_lock"></span> <span class="verticalReader_catalog_item_text">第12章 自动化测试</span></a></li><li disabled="disabled" id="catalog_item_19" class="verticalReader_catalog_item"><a href="javascript:;" class="verticalReader_catalog_link"><span class="verticalReader_catalog_item_lock"></span> <span class="verticalReader_catalog_item_text">第13章 性能优化</span></a></li><li disabled="disabled" id="catalog_item_20" class="verticalReader_catalog_item"><a href="javascript:;" class="verticalReader_catalog_link"><span class="verticalReader_catalog_item_lock"></span> <span class="verticalReader_catalog_item_text">第14章 部署上线</span></a></li><li disabled="disabled" id="catalog_item_21" class="verticalReader_catalog_item"><a href="javascript:;" class="verticalReader_catalog_link"><span class="verticalReader_catalog_item_lock"></span> <span class="verticalReader_catalog_item_text">附录A Flask资源</span></a></li><!----></ul></div><!----><!----></div><script>config.vueBook = {"bookId":"22987517","title":"Flask Web开发实战：入门、进阶与原理解析","author":"李辉","cover":"https://wfqqreader-1252317822.image.myqcloud.com/cover/517/22987517/s_22987517.jpg","version":1313596851,"format":"epub","price":89,"originalPrice":0,"soldout":0,"bookStatus":1,"payType":4097,"finished":1,"maxFreeChapter":13,"type":0,"free":0,"mcardDiscount":0,"ispub":1,"centPrice":8900,"category":"科学技术-计算机网络","source":"所有书籍均已获得正版授权","hasLecture":0,"intro":"本书由三部分组成，分别为基础篇、实战篇、进阶篇，共16章。本书章节经过精心设计，力求让读者可以循序渐进地掌握Flask开发的基础知识和技巧。本书包含大量代码片段，并附带多个完整可运行的示例程序。在本书第一部分的第2～6章均分别提供一个示例程序；第二部分则会通过介绍5个比较完善的Flask项目来讲解各个方面的进阶知识；在第三部分还会通过一个真实的扩展来讲解Flask扩展开发。通过将各类知识融入实际的项目开发实践中，可以让你更直观地了解具体的代码实现，并且快速应用到实际开发中。","lastChapterIdx":21,"chapterSize":21,"updateTime":1552746417,"unitPrice":0,"marketType":0,"isbn":"9787111606598","cpid":2000000121,"publisher":"机械工业出版社","publishTime":"2018-08-01 00:00:00","totalWords":347173,"publishPrice":129,"bookSize":2214658,"recommended":0,"lectureRecommended":0,"follow":0,"secret":0,"offline":0,"lectureOffline":0,"finishReading":0,"isAutoPay":0,"availables":0,"paid":0,"showLectureButton":1,"star":81,"ratingCount":47,"ratingDetail":{"one":0,"two":0,"three":16,"four":86,"five":896}};
    config.vueChapter = {"content":"\u003cp>第7章 留言板\u003c/p>\u003cp>第一个示例程序是一个非常简单的留言板程序Say Hello，编写时涉及的知识完全是我们在第一部分学习的内容。这一章，我们会基于这个程序介绍一种组织项目代码的形式。在程序的编写过程中，我们还会了解Web程序的开发流程，对第一部分学习的基础内容进行一个简单的回顾和复习，并学习几个新的Flask扩展。\u003c/p>\u003cp>本章新涉及的Python包如下所示：\u003c/p>\u003cp>❑ Bootstrap-Flask（0.1.0）\u003c/p>\u003cp>❍主页：https://github.com/greyli/bootstrap-flask\u003c/p>\u003cp>❍文档：https://bootstrap-flask.readthedocs.io\u003c/p>\u003cp>❑ Flask-Moment（0.6.0）\u003c/p>\u003cp>❍主页：https://github.com/miguelgrinberg/Flask-Moment\u003c/p>\u003cp>❑ Faker（0.8.13）\u003c/p>\u003cp>❍主页：https://github.com/joke2k/faker\u003c/p>\u003cp>❍文档：http://faker.readthedocs.io\u003c/p>\u003cp>❑ Flask-Debug Toolbar（0.10.1）\u003c/p>\u003cp>❍主页：https://github.com/mgood/flask-debugtoolbar\u003c/p>\u003cp>❍文档：https://flask-debugtoolbar.readthedocs.io\u003c/p>\u003cp>请打开一个新的命令行窗口，切换到合适的目录，然后使用下面的命令将示例程序仓库复制到本地：\u003c/p>\u003cp>$ git clone https://github.com/greyli/sayhello.git\u003c/p>\u003cp>提示\u003c/p>\u003cp>如果你在Say Hello的Git Hub页面（https://github.com/greyli/sayhello）页面单击了Fork按钮，那么可以使用你自己的Git Hub用户名来替换上面的greyli，这将复制一份派生仓库，你可以自由地修改和提交代码。\u003c/p>\u003cp>接着，切换到项目文件夹中，使用Pipenv创建虚拟环境，这会同时安装所有依赖（--dev选项用来包括开发依赖），这应该会花费一些时间，安装完成后激活虚拟环境：\u003c/p>\u003cp>$ cd sayhello         $ pipenv install --dev         $ pipenv shell\u003c/p>\u003cp>最后创建虚拟数据（flask forge是用来生成虚拟数据的自定义命令，我们会在后面详细介绍），并启动程序：\u003c/p>\u003cp>$ flask forge         $ flask run\u003c/p>\u003cp>在浏览器访问http://127.0.0.1:5000或http://localhost:5000即可体验我们本章要实现的Say Hello程序。\u003c/p>\u003cp>注意\u003c/p>\u003cp>和本书第一部分的示例程序相同，第二部分所有的示例程序都运行在本地机的5000端口，即http://localhost:5000，确保没有其他程序同时在运行。\u003c/p>\u003cp>注意\u003c/p>\u003cp>因为所有示例程序的CSS文件名称、Java Script文件名称以及Favicon文件名称均相同，为了避免浏览器对不同示例程序中同名的文件进行缓存，请在第一次运行新的示例程序后按下Crtl+F5或Shift+F5清除缓存。\u003c/p>\u003cp>阅读源码时，可以使用下面的命令签出初始版本：\u003c/p>\u003cp>$ git checkout package\u003c/p>\u003cp>使用git tag-n命令可以列出项目包含的所有标签，在对应的章节中我也会给出签出提示，每一个版本的程序都可以运行。你也可以在Git Hub上阅读代码，Say Hello的Git Hub主页为（https://github.com/greyli/sayhello），通过branch下拉列表中的Tags标签可以查看不同标签的源码。\u003c/p>\u003cp>提示\u003c/p>\u003cp>在Git Hub上也可以查看不同标签之间的程序代码变化，比如，第一个标签package和第二个标签bootstrap的源码变动对比可以访问https://github.com/greyli/sayhello/compare/package...bootstrap查看，其他标签以此类推。\u003c/p>\u003cp>7.1 使用包组织代码\u003c/p>\u003cp>本书第一部分的示例程序都采用单脚本的形式存储代码。随着项目逐渐变大，把所有的代码都放在app.py里会导致可读性降低，不方便管理，我们需要更好的代码组织方式。\u003c/p>\u003cp>Flask对项目的组织方式没有要求。对于小型项目，你完全可以把代码都放在一个主模块里，这也是第一部分的示例程序的组织方式。随着项目越来越大，更好的处理方式是将单一的模块升级为包（Package），把不同部分的代码分模块存放。\u003c/p>\u003cp>附注\u003c/p>\u003cp>在Python中，每一个有效的Python文件（.py）都是模块。每一个包含__init__.py文件的文件夹都被视作包，包让你可以使用文件夹来组织模块。__init__.py文件通常被称作构造文件，文件可以为空，也可以用来放置包的初始化代码。当包或包内的模块被导入时，构造文件将被自动执行。\u003c/p>\u003cp>Say Hello程序的核心组件都放到一个包中，这个包称为程序包，包的名称通常使用程序名称，即sayhello，有时为了方便管理也会使用app作为包名称。除了程序代码，一个基本的Flask项目还包括其他必要的组件，表7-1列出了当前程序包的主要组件及其功能说明。\u003c/p>\u003cp>表7-1 Say Hello程序包组件和结构\u003c/p>\u003cp>在后面的开发中，各类代码都会按照类别存储在对应的模块中。这里的模块并不是固定的，如果你需要组织其他代码，那么可以自己创建对应的模块。比如，你可以创建一个callbacks.py脚本来存储各种注册在程序实例上的处理函数。相对的，如果你不需要创建自定义命令，那么也可以不创建commands.py脚本。\u003c/p>\u003cp>7.1.1 配置文件\u003c/p>\u003cp>在Flask中，配置不仅可以通过config对象直接写入，还可以从文件中读取。在Say Hello中，把配置移动到一个单独的文件中，将其命名为settings.py（也常被命名为config.py）。当在单独的文件中定义配置时，不再使用config对象添加配置，而是直接以键值对的方式写出，和保存环境变量的.flaskenv文件非常相似。代码清单7-1是当前的配置文件。\u003c/p>\u003cp>代码清单7-1 sayhello/settings.py：配置文件\u003c/p>\u003cp>import os         from sayhello import app               dev_db = &#x27;sqlite:///&#x27; + os.path.join(os.path.dirname(app.root_path), &#x27;data.db&#x27;)         SECRET_KEY = os.getenv(&#x27;SECRET_KEY&#x27;, &#x27;secret string&#x27;)         SQLALCHEMY_TRACK_MODIFICATIONS = False         SQLALCHEMY_DATABASE_URI = os.getenv(&#x27;DATABASE_URI&#x27;, dev_db)\u003c/p>\u003cp>提示\u003c/p>\u003cp>除了从Python脚本导入配置，Flask还提供了其他方式，比如使用from_json()方法从JSON文件中导入，或是使用from_object()方法从Python对象导入，详情见http://flask.pocoo.org/docs/latest/config/。\u003c/p>\u003cp>上面的配置和第一部分的示例程序相比有一点变化，由于配置文件被放到了程序包内，为了定位到位于项目根目录的数据库文件，使用os.path.dirname(app.root_path)获取上层目录， app.root_path属性存储程序实例所在的路径。数据库URL和密钥都会首先从环境变量获取。\u003c/p>\u003cp>在创建程序实例后，使用config对象的from_pyfile()方法即可加载配置，传入配置模块的文件名作为参数：\u003c/p>\u003cp>...         app = Flask(__name__)         app.config.from_pyfile(&#x27;settings.py&#x27;)\u003c/p>\u003cp>7.1.2 创建程序实例\u003c/p>\u003cp>使用包组织程序代码后，创建程序实例、初始化扩展等操作可以在程序包的构造文件（__init__.py）中实现，如代码清单7-2所示。\u003c/p>\u003cp>代码清单7-2 sayhello/__init__.py：创建程序实例、初始化扩展\u003c/p>\u003cp>from flask import Flask         from flask_sqlalchemy import SQLAlchemy         app = Flask(&#x27;sayhello&#x27;)         app.config.from_pyfile(&#x27;settings.py&#x27;)         app.jinja_env.trim_blocks = True         app.jinja_env.lstrip_blocks = True         db = SQLAlchemy(app)         from sayhello import views, errors, commands\u003c/p>\u003cp>在单脚本中创建程序实例时，我们传入__name__变量作为Flask类构造方法的import_name参数值。因为Flask通过这个值来确认程序路径，当使用包组织代码时，为了确保其他扩展或测试框架获得正确的路径值，我们最好以硬编码的形式写出包名称作为程序名称，即sayhello。\u003c/p>\u003cp>提示\u003c/p>\u003cp>除了直接写出包名称，你也可以从__name__变量获取包名称，即app = Flask(__name__.split(&#x27;.&#x27;)[0])。\u003c/p>\u003cp>当我们启动程序时，首先被执行的是包含程序实例的脚本，即构造文件。但注册在程序实例上的各种处理程序均存放在其他脚本中，比如视图函数存放在views.py中、错误处理函数则存放在errors.py中。如果不被执行，那么这些视图函数和错误处理函数就不会注册到程序上，那么程序也无法正常运行。为了让使用程序实例app注册的视图函数，错误处理函数，自定义命令函数等和程序实例关联起来，我们需要在构造文件中导入这些模块。因为这些模块也需要从构造文件中导入程序实例，所以为了避免循环依赖，这些导入语句在构造文件的末尾定义。\u003c/p>\u003cp>提示\u003c/p>\u003cp>从构造文件中导入变量时不需要注明构造文件的路径，只需要从包名称导入，比如导入在构造文件中定义的程序实例app可以使用from sayhello import app。\u003c/p>\u003cp>在前面的章节中说过，Flask在通过FLASK_APP环境变量定义的模块中寻找程序实例。所以在启动程序前，我们需要给．flaskenv中的环境变量FLASK_APP重新赋值，这里仅写出包名称即可：\u003c/p>\u003cp>...         FLASK_APP=sayhello\u003c/p>\u003cp>7.2 Web程序开发流程\u003c/p>\u003cp>在实际的开发中，一个Web程序的开发过程要涉及多个角色，比如客户（提出需求）、项目经理（决定需求的实现方式）、开发者（实现需求）等，在这里我们假设是一个人全职开发。一般来说，一个Web程序的开发流程如下所示：\u003c/p>\u003cp>1）分析需求，列出功能清单或写需求说明书。\u003c/p>\u003cp>2）设计程序功能，写功能规格书和技术规格书。\u003c/p>\u003cp>3）进入开发与测试的迭代。\u003c/p>\u003cp>4）调试和性能等专项测试。\u003c/p>\u003cp>5）部署上线（deployment）。\u003c/p>\u003cp>6）运行维护与营销等。\u003c/p>\u003cp>写好功能规格书后，我们就可以进行实际的代码编写。在具体的开发中，代码编写主要分为前端页面（front end）和后端程序（back end）。前端开发的主要流程如下：\u003c/p>\u003cp>1）根据功能规格书画页面草图（sketching）。\u003c/p>\u003cp>2）根据草图做交互式原型图（prototyping）。\u003c/p>\u003cp>3）根据原型图开发前端页面（HTML、CSS、Java Script）。\u003c/p>\u003cp>后端开发的主要流程如下：\u003c/p>\u003cp>1）数据库建模。\u003c/p>\u003cp>2）编写表单类。\u003c/p>\u003cp>3）编写视图函数和相关的处理函数。\u003c/p>\u003cp>4）在页面中使用Jinja2替换虚拟数据。\u003c/p>\u003cp>采用这个流程并不是必须的，对于非常简单的程序（比如本章的Say Hello），你可以根据情况来省略某些步骤。如果不是只有简单的几个页面的玩具程序，那么我建议你遵循这个过程进行开发。因为如果没有规划，就会像没头苍蝇一样乱飞乱撞，最终开发出不完善的程序，或是添加了无关紧要的功能。从一开始就遵循开发流程，可以让你很容易适应大型程序的开发。想象一下，在大型程序里常常有着复杂的数据库关系，大量的页面和功能，想到哪写到哪会将大量时间都浪费在无意义的调试和删改中。前期考虑和规划越周全，在实际开发时就可以越高效和省力。\u003c/p>\u003cp>为了便于组织内容，开发时非常重要的测试，我们移动到本书的第三部分进行介绍，但是在实际开发中应该将测试融入整个开发流程中：每编写一部分代码，立刻编写对应的测试。在第三部分我们还会介绍程序的部署以及部署前的准备（性能优化）。\u003c/p>\u003cp>提示\u003c/p>\u003cp>为了不偏离主题，我们这里仅对Flask程序的开发做一个简单的介绍，你可以阅读相关书籍了解更多细节，后面的程序实例不再详细介绍这个过程。\u003c/p>\u003cp>7.2.1 程序功能设计\u003c/p>\u003cp>规划和设计程序功能时，我们通常会使用思维导图工具或是清单工具。因为Say Hello非常简单，所以我打算创建一个非常简短的功能规格书，如下所示：\u003c/p>\u003cp>概述\u003c/p>\u003cp>Say Hello是一个类似于留言板的程序，用来让用户发表问候，对任何人任何事的问候。比如，用户A想问候这个世界，就可以在页面上发表一句“Hello, World!”。Say Hello的使用流程非常简单，我们甚至不需要画流程图。用户输入问候信息和姓名，按下提交按钮，就可以将问候加入到页面的消息列表中。\u003c/p>\u003cp>主页\u003c/p>\u003cp>主页是Say Hello唯一的页面，页面中包含创建留言的表单以及所有的问候消息。页面上方是程序的标题“Say Hello”，使用大字号和鲜艳的颜色。页面底部包含程序的版权标志、编写者、源码等相关信息。\u003c/p>\u003cp>问候表单\u003c/p>\u003cp>这个表单包含姓名和问候消息两个字段，其中姓名字段是普通的文本字段&lt;input type=&quot;text&quot;&gt;，而消息字段是文本区域字段&lt;textarea&gt;&lt;/textarea&gt;。为了获得良好的样式效果，对这两个字段的输入值进行长度上的限制，姓名最长为20个字符，而问候消息最长为200个字符。\u003c/p>\u003cp>用户提交发布表单后：\u003c/p>\u003cp>1）如果验证出错，错误消息以红色小字的形式显示在字段下面；\u003c/p>\u003cp>2）如果通过验证，则在程序标题下面显示一个提示消息，用户可以通过消息右侧的按钮关闭提示。\u003c/p>\u003cp>问候消息列表\u003c/p>\u003cp>问候消息列表的上方显示所有消息的数量。每一条问候消息要包含的信息有发布者姓名、消息正文、发布的时间、消息的编号。消息发布时间要显示相对时间，比如“3分钟前”，当鼠标悬停在时间上时，弹出窗口显示具体的时间值。消息根据时间先后排序，最新发表的排在最上面。为了方便用户查询最早的消息，我们提供一个前往页面底部的按钮，同时提供一个回到页面顶部的按钮。\u003c/p>\u003cp>错误页面\u003c/p>\u003cp>错误页面包括404错误页面和500错误页面，和主页包含相同的部分——程序标题。程序标题下显示错误信息以及一个返回主页的“Go Back”链接。为了保持简单，错误页面不加入页脚信息。\u003c/p>\u003cp>7.2.2 前端页面开发\u003c/p>\u003cp>在前面列出的流程中，我们首先使用纸笔画草图，然后使用原型设计软件画出原型图，最后编写对应的HTML页面。根据程序的页面数量和复杂程度，你可以按需调整。因为Say Hello比较简单，我们直接使用原型工具画出原型图即可。\u003c/p>\u003cp>Say Hello的主页原型图如图7-1所示。\u003c/p>\u003cp>图7-1 主页原型图\u003c/p>\u003cp>附注\u003c/p>\u003cp>常用的原型设计工具有Axure RP（https://www.axure.com/）、Mockplus（https://www. mockplus.cn/）等。\u003c/p>\u003cp>错误页面原型图（404）如图7-2所示。\u003c/p>\u003cp>图7-2 404错误页面原型图\u003c/p>\u003cp>为了简化工作量，我们使用Bootstrap来编写页面样式。根据原型图编写的主页HTML页面如图7-3所示。\u003c/p>\u003cp>图7-3 主页HTML页面\u003c/p>\u003cp>根据原型图编写的错误页面HTML页面如图7-4所示。\u003c/p>\u003cp>图7-4 错误页面\u003c/p>\u003cp>在传统的Flask程序中，后端完成功能后会操作HTML代码，在其中添加Jinja2语句。比如，将页面中的临时URL替换为url_for()函数调用，把虚拟数据换成通过视图函数传入模板的变量，或是使用模板继承等技术组织这些HTML文件。我们会在7.2.3节中详细介绍。\u003c/p>\u003cp>7.2.3 后端程序开发\u003c/p>\u003cp>后端开发的相关知识我们在本书的第一部分已经介绍得差不多了，这里再进行一个快速回顾。\u003c/p>\u003cp>1．数据库建模\u003c/p>\u003cp>编写完功能规格书后，我们也就确定了需要使用哪些表来存储数据，表中需要创建哪些字段以及各个表之间的关系。对于复杂的数据库结构，你可以使用建模工具来辅助建立数据库关系。在Say Hello中，用于保存留言的Message模型如代码清单7-3所示。\u003c/p>\u003cp>代码清单7-3 sayhello.py：定义Message模型\u003c/p>\u003cp>from datetime import datetime         from sayhello import db         class Message(db.Model):             id = db.Column(db.Integer, primary_key=True)             body = db.Column(db.String(200))             name = db.Column(db.String(20))         timestamp = db.Column(db.DateTime, default=datetime.now, index=True)\u003c/p>\u003cp>timestamp字段用来存储每一条留言的发表时间（时间戳），这个字段存储Python的datetime对象。在这个字段中，我们将index设为True来开启索引，并使用default参数设置了字段默认值。\u003c/p>\u003cp>注意\u003c/p>\u003cp>timestamp字段的默认值是datetime.now而不是datetime.now()。前者是可调用的函数/方法对象（即名称），而后者是函数/方法调用（即动作）。SQLAlchemy会在创建新的数据库记录时（即用户提交表单实例化Message类时）调用该对象来设置默认值，这也是我们期待的效果。如果传入的不是方法对象，那么这个方法在加载模块时就会被执行，这将不是正确的时间戳。\u003c/p>\u003cp>为了方便在开发时重新创建数据库表，我们还添加了一个初始化数据库的initdb命令，和第5章介绍过的initdb()命令函数完全相同。\u003c/p>\u003cp>2．创建表单类\u003c/p>\u003cp>问候表单由表单类Hello Form表示，表单中使用了文本区域字段Text Area Field，表示HTML中的&lt;textarea&gt;标签，如代码清单7-4所示。\u003c/p>\u003cp>代码清单7-4 forms.py：问候表单\u003c/p>\u003cp>from flask_wtf import FlaskForm         from wtforms import StringField, SubmitField, TextAreaField         from wtforms.validators import DataRequired, Length         class HelloForm(FlaskForm):             name = StringField(&#x27;Name&#x27;, validators=[DataRequired(), Length(1, 20)])             body = TextAreaField(&#x27;Message&#x27;, validators=[DataRequired(), Length(1, 200)])             submit = SubmitField()\u003c/p>\u003cp>3．编写视图函数\u003c/p>\u003cp>错误处理函数比较简单，我们重点介绍一下index视图。index视图有两个作用：\u003c/p>\u003cp>1）处理GET请求，从数据库中查询所有的消息记录，返回渲染后的包含消息列表的主页模板index.html。\u003c/p>\u003cp>2）处理POST请求，问候表单提交后，验证表单数据，通过验证后将数据保存到数据库中，使用flash()函数显示一条提示，然后重定向到index视图，渲染页面。\u003c/p>\u003cp>具体示例如代码清单7-5所示。\u003c/p>\u003cp>代码清单7-5 sayhello/views.py：index视图\u003c/p>\u003cp>from flask import flash, redirect, url_for, render_template         from sayhello import app, db         from sayhello.models import Message         from sayhello.forms import HelloForm         @app.route(&#x27;/&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])         def index():             # 加载所有的记录             messages = Message.query.order_by(Message.timestamp.desc()).all()             form = HelloForm()             if form.validate_on_submit():                 name = form.name.data                 body = form.body.data                 message = Message(body=body, name=name)  # 实例化模型类，创建记录                 db.session.add(message)  # 添加记录到数据库会话                 db.session.commit()  # 提交会话                 flash(&#x27;Your message have been sent to the world! &#x27;)                 return redirect(url_for(&#x27;index&#x27;))  # 重定向到index视图             return render_template(&#x27;index.html&#x27;, form=form, messages=messages)\u003c/p>\u003cp>在获取message记录时，我们使用order_by()过滤器对数据库记录进行排序，参数是排序的规则。我们根据Message模型的timestamp字段值排序，字段上附加的排序方法为desc()，代表降序（descending），同样还有一个asc()方法表示升序（ascending）。\u003c/p>\u003cp>4．编写模板\u003c/p>\u003cp>我们将index.html和404.html，以及500.html中的共有部分抽出合并为基模板base.html。基模板包含一个完整的HTML结构，我们在其中创建了几个块：title、content和footer，如代码清单7-6所示。\u003c/p>\u003cp>代码清单7-6 templates/base.html：基模板\u003c/p>\u003cp>&lt;! DOCTYPE html&gt;         &lt;html lang=&quot;en&quot;&gt;         &lt;head&gt;             &lt;meta charset=&quot;utf-8&quot;&gt;             &lt;meta  name=&quot;viewport&quot;  content=&quot;width=device-width,  initial-scale=1,  shrink-                 to-fit=no&quot;&gt;             &lt;title&gt;{% block title %}Say Hello! {% endblock %}&lt;/title&gt;             &lt;link rel=&quot;icon&quot; href=&quot;{{ url_for(&#x27;static&#x27;, filename=&#x27;favicon.ico&#x27;) }}&quot;&gt;             &lt;link  rel=&quot;stylesheet&quot;  href=&quot;{{  url_for(&#x27;static&#x27;,  filename=&#x27;css/bootstrap.                 min.css&#x27;) }}&quot; type=&quot;text/css&quot;&gt;             &lt;link  rel=&quot;stylesheet&quot;  href=&quot;{{  url_for(&#x27;static&#x27;,  filename=&#x27;css/style.css&#x27;)                 }}&quot; type=&quot;text/css&quot;&gt;         &lt;/head&gt;         &lt;body&gt;         &lt;main class=&quot;container&quot;&gt;             &lt;header&gt;                 &lt;h1 class=&quot;text-center display-4&quot;&gt;                     &lt;a href=&quot;{{  url_for(&#x27;index&#x27;)  }}&quot;  class=&quot;text-success&quot;&gt;&lt;strong&gt;Say                         Hello&lt;/strong&gt;&lt;/a&gt;                     &lt;small  style=&quot;font-size:  24px&quot;  class=&quot;text-muted&quot;&gt;to  the  world&lt;/                         small&gt;                 &lt;/h1&gt;             &lt;/header&gt;             {% for message in get_flashed_messages() %}             &lt;div class=&quot;alert alert-info&quot;&gt;                 &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;alert&quot;&gt;. &lt;/button&gt;                 {{ message }}             &lt;/div&gt;             {% endfor %}             {% block content %}{% endblock %}             &lt;footer class=&quot;text-center&quot;&gt;                 {% block footer %}                   .                 &lt;p&gt;&lt;a id=&quot;bottom&quot; href=&quot;#&quot; title=&quot;Go Top&quot;&gt;&uarr; &lt;/a&gt;&lt;/p&gt;                 {% endblock %}             &lt;/footer&gt;         &lt;/main&gt;         &lt;script  type=&quot;text/javascript&quot;  src=&quot;{{  url_for(&#x27;static&#x27;,  filename=&#x27;js/jquery-             3.2.1.slim.min.js&#x27;) }}&quot;&gt;&lt;/script&gt;         &lt;script type=&quot;text/javascript&quot; src=&quot;{{ url_for(&#x27;static&#x27;, filename=&#x27;js/popper.min.             js&#x27;) }}&quot;&gt;&lt;/script&gt;         &lt;script type=&quot;text/javascript&quot; src=&quot;{{ url_for(&#x27;static&#x27;, filename=&#x27;js/bootstrap.             min.js&#x27;) }}&quot;&gt;&lt;/script&gt;         &lt;script type=&quot;text/javascript&quot; src=&quot;{{ url_for(&#x27;static&#x27;, filename=&#x27;js/script.js&#x27;)             }}&quot;&gt;&lt;/script&gt;         &lt;/body&gt;         &lt;/html&gt;\u003c/p>\u003cp>在head标签和body标签内，我们引入了Bootstrap所需的CSS和Java Script文件，以及Bootstrap所依赖的j Query和Popper.js。另外，我们还引入了自定义的style.css和script.js文件，这两个文件分别用来存储自定义的CSS样式定义和Java Script代码。\u003c/p>\u003cp>附注\u003c/p>\u003cp>这里为消息应用了Bootstrap提供的alert-info样式（蓝色背景），后面我们会学习对flash消息添加分类，以便对不同类别的消息应用不同的样式。\u003c/p>\u003cp>在主页模板index.html中，我们使用form_field()宏渲染表单，然后迭代传入的messages变量，渲染消息列表，如代码清单7-7所示。\u003c/p>\u003cp>代码清单7-7 index.html：渲染表单和留言列表\u003c/p>\u003cp>{% extends &#x27;base.html&#x27; %}         {% from &#x27;macros.html&#x27; import form_field %}         {% block content %}         &lt;div class=&quot;hello-form&quot;&gt;             &lt;form method=&quot;post&quot; action=&quot;{{request.full_path}}&quot;&gt;                 {{ form.csrf_token }}                 &lt;div class=&quot;form-group required&quot;&gt;                     {{ form_field(form.name, class=&#x27;form-control&#x27;) }}                 &lt;/div&gt;                 &lt;div class=&quot;form-group required&quot;&gt;                     {{ form_field(form.body, class=&#x27;form-control&#x27;) }}                 &lt;/div&gt;                 {{ form.submit(class=&#x27;btn btn-secondary&#x27;) }}             &lt;/form&gt;         &lt;/div&gt;         &lt;h5&gt;{{ messages|length }} messages             &lt;small class=&quot;float-right&quot;&gt;                 &lt;a href=&quot;#bottom&quot; title=&quot;Go Bottom&quot;&gt;&darr; &lt;/a&gt;             &lt;/small&gt;         &lt;/h5&gt;         &lt;div class=&quot;list-group&quot;&gt;             {% for message in messages %}                 &lt;a class=&quot;list-group-item list-group-item-action flex-column&quot;&gt;                     &lt;div class=&quot;d-flex w-100 justify-content-between&quot;&gt;                         &lt;h5 class=&quot;mb-1 text-success&quot;&gt;{{ message.name }}                             &lt;small class=&quot;text-muted&quot;&gt; #{{ loop.revindex }}&lt;/small&gt;                         &lt;/h5&gt;                         &lt;small&gt;                             {{ message.timestamp.strftime(&#x27;%Y/%m/%d %H:%M&#x27;) }}                         &lt;/small&gt;                     &lt;/div&gt;                     &lt;p class=&quot;mb-1&quot;&gt;{{ message.body }}&lt;/p&gt;                 &lt;/a&gt;             {% endfor %}         &lt;/div&gt;         {% endblock %}\u003c/p>\u003cp>提示\u003c/p>\u003cp>我们曾在第4章介绍过，表单默认提交到当前URL。如果用户单击了向下按钮，会在URL中添加URL片段，比如“#bottom”，它指向页面底部的a元素（其id值为bottom），所以会跳转到页面底部（关于URL片段我们会在第8章详细了解）。当表单被提交后，页面加载时仍会跳转到URL片段对应的位置，为了避免这个行为，可以显式地使用action属性指定表单提交的目标URL，使用request.full_path获取没有URL片段的当前请求URL。\u003c/p>\u003cp>渲染时间戳时，我们使用datetime.strftime()方法将时间戳输出格式定义为：“年/月/日时：分”，这显然不是我们设计功能时想要的时间，在后面我们借助其他工具来获取相对时间并显示绝对时间弹窗。除了时间戳外，我们还渲染了loop.revindex变量，用来表示留言的反向序号标记。\u003c/p>\u003cp>7.3 使用Bootstrap-Flask简化页面编写\u003c/p>\u003cp>扩展Bootstrap-Flask内置了可以快速渲染Bootstrap样式HTML组件的宏，并提供了内置的Bootstrap资源，方便快速开发，使用它可以简化在Web程序里集使用Bootstrap的过程。\u003c/p>\u003cp>提示\u003c/p>\u003cp>扩展Bootstrap-Flask基于扩展Flask-Bootstrap（https://github.com/mbr/flask-bootstrap）实现，旨在替代缺乏维护的后者。和Flask-Bootstrap相比，Bootstrap-Flask简化了大部分功能（比如未内置基模板），添加了Bootstrap4支持，并增加了一些辅助功能。\u003c/p>\u003cp>提示\u003c/p>\u003cp>如果你从Git Hub上复制了示例程序，可以执行git checkout bootstrap签出程序的新版本。\u003c/p>\u003cp>首先使用Pipenv安装Bootstrap-Flask：\u003c/p>\u003cp>$ pipenv install bootstrap-flask\u003c/p>\u003cp>需要注意，Bootstrap-Flask提供的包名称为flask_bootstrap，我们从这个包导入并实例化Bootstrap类，传入程序实例app，以完成扩展的初始化：\u003c/p>\u003cp>from flask import Flask         from flask_bootstrap import Bootstrap         app = Flask(__name__)         bootstrap = Bootstrap(app)\u003c/p>\u003cp>7.3.1 加载资源文件\u003c/p>\u003cp>Bootstrap-Flask在模板中提供了一个bootstrap对象，这个对象提供了两个方法可以用来生成资源引用代码：用来加载CSS文件的bootstrap.load_css()方法和用来加载Java Script文件（包括Bootstrap、j Query、Popper.js）的bootstrap.load_js()方法。Flask-Bootstrap默认从CDN（Content Delivery Network，内容分发网络）加载Bootstrap资源，同时也提供了内置的本地资源。如果你想使用Bootstrap-Flask提供的本地资源，可以将配置变量BOOTSTRAP_SERVE_LOCAL设为True。另外，当FLASK_ENV环境变量设为development时，Bootstrap-Flask将自动使用本地资源。\u003c/p>\u003cp>提示\u003c/p>\u003cp>尽管使用这些方法非常方便，但我们最好在开发时自己手动管理本地静态资源。Say Hello的static目录下包含了所有需要的资源文件，基模板中的资源文件都从static文件夹中引入。\u003c/p>\u003cp>如果你想使用Bootstrap-Flask提供的方法加载资源，那么只需要在相应的位置分别调用资源加载方法，替换掉这些对应的资源加载语句即可：\u003c/p>\u003cp>&lt;head&gt;             {{ bootstrap.load_css() }}         &lt;/head&gt;         &lt;body&gt;               .             {{ bootstrap.load_js() }}         &lt;/body&gt;\u003c/p>\u003cp>另外，在bootstrap_load_js()方法中，使用with_jquery和with_popper可以设置是否加载j Query和Popper.js的Java Script资源，默认为True，设为False可以关闭。\u003c/p>\u003cp>7.3.2 快捷渲染表单\u003c/p>\u003cp>Bootstrap-Flask内置了两个用于渲染WTForms表单类的宏，一个是与我们第4章创建的form_field宏类似的render_field()宏，另一个是用来快速渲染整个表单的render_form()宏。这两个宏都会自动渲染错误消息，渲染表单的验证状态样式。\u003c/p>\u003cp>Bootstrap-Flask提供的表单渲染宏通过其内置的bootstrap/form.html模板导入，render_field()宏的使用方式和我们自己编写的form_field()宏完全相同。值得特别介绍的是render_form()宏，它使用起来更加简单，使用一行代码就可以渲染整个表单，而且会自动帮我们渲染CSRF令牌字段form.csrf_token。下面使用这个宏在index.html模板中渲染问候表单：\u003c/p>\u003cp>{% extends &#x27;base.html&#x27; %}         {% from &#x27;bootstrap/form.html&#x27; import render_form %}         {% block content %}             &lt;div class=&quot;hello-form&quot;&gt;                 {{ render_form(form), action=request.full_path}}             &lt;/div&gt;         {% endblock %}\u003c/p>\u003cp>它将会自动为你创建一个&lt;form&gt;标签，然后在标签内依次渲染包括CSRF令牌在内的所有字段。除了渲染表单字段，它还会根据表单的验证状态来渲染表单状态和错误消息。一般情况下，你只需要传入表单类实例作为参数。除此之外，quick_form()宏还支持许多参数来自定义表单，常用的参数及说明如表7-2所示。\u003c/p>\u003cp>表7-2 render_form()宏常用参数\u003c/p>\u003cp>包括用来渲染表单的render_field()和render_form()宏在内，Bootstrap-Flask还提供了许多其他用途的宏，这些宏都可以通过bootstrap目录下的模板导入，具体用法我们会在后面介绍。常用的Bootstrap-Flask宏如表7-3所示。\u003c/p>\u003cp>表7-3 Bootstrap-Flask内置的常用宏\u003c/p>\u003cp>附注\u003c/p>\u003cp>完整的可用宏列表请访问Bootstrap-Flask文档的宏页面（https://bootstrap-flask.readthedocs. io/en/latest/macros.html）查看。\u003c/p>\u003cp>7.4 使用Flask-Moment本地化日期和时间\u003c/p>\u003cp>在Message类中，我们存储时间戳时使用的是datetime模块的datetime.now()方法生成的datetime对象，它是一个本地时间。具体来说，这个方法会返回服务器（也就是运行程序的计算机）设置的时区所对应的时间。对于测试来说这足够了，但如果我要把程序部署到真正的服务器上，就可能会面临时区问题。比如，我把程序部署到美国的服务器上，那么这个时间将不再是我们期待的东八区时间，而是服务器本地的美国时间。另一方面，如果我们的程序被其他时区的人访问，他们更希望看到自己所在时区的时间，而不是固定的东八区时间。\u003c/p>\u003cp>提示\u003c/p>\u003cp>如果你从Git Hub上复制了示例程序，可以执行git checkout moment签出程序的新版本。\u003c/p>\u003cp>7.4.1 本地化前的准备\u003c/p>\u003cp>如何让世界各地的用户访问程序时都能看到自己的本地时间呢？一个简单的方法是使用Java Script库在客户端（浏览器）中进行时间的转换，因为浏览器可以获取到用户浏览器/电脑上的时区设置信息。\u003c/p>\u003cp>为了能够在客户端进行时间的转换，我们需要在服务器端提供纯正的时间（naive time），即不包含时区信息的时间戳（与之相对，包含时区的时间戳被称为细致的时间，即aware time）。datetime模块的datetime.utcnow()方法用来生成当前的UTC（Coordinated Universal Time，协调世界时间），而UTC格式时间就是不包含时区信息的纯正时间。我们将使用它在时间戳字段上替代之前的datetime.now方法，作为时间戳timestamp字段的默认值：\u003c/p>\u003cp>from datetime import datetime         ...         class Message(db.Model):             ...             timestamp = db.Column(db.DateTime, default=datetime.utcnow)\u003c/p>\u003cp>7.4.2 使用Flask-Moment集成Moment.js\u003c/p>\u003cp>Moment.js（https://momentjs.com/）是一个用于处理时间和日期的开源Java Script库，它可以对时间和日期进行各种方式的处理。它会根据用户电脑中的时区设置在客户端使用Java Script来渲染时间和日期，另外它还提供了丰富的时间渲染格式支持。\u003c/p>\u003cp>扩展Flask-Moment简化了在Flask项目中使用Moment.js的过程，集成了常用的时间和日期处理函数。首先使用Pipenv安装：\u003c/p>\u003cp>$ pipenv install flask-moment\u003c/p>\u003cp>然后我们实例化扩展提供的Moment类，并传入程序实例app，以完成扩展的初始化：\u003c/p>\u003cp>from flask_moment import Moment         app = Flask(__name__)         ...         moment = Moment(app)\u003c/p>\u003cp>为了使用Moment.js，我们需要在基模板中加载Moment.js资源。Flask-Moment在模板中提供了moment对象，这个对象提供两个方法来加载资源：moment.include_moment()方法用来加载Moment.js的Javascript资源；moment.include_jquery()用来加载j Query。这两个方法默认从CDN加载资源，传入local_js参数可以指定本地资源URL。\u003c/p>\u003cp>提示\u003c/p>\u003cp>我们在使用Bootstrap时已经加载了j Query，这里只需要加载Moment.js的Java Script文件。\u003c/p>\u003cp>基于同样的理由，我们将在程序中手动加载资源。首先访问Moment.js官网（https://momentjs.com/）下载相应的资源文件到static文件夹，然后在基模板中引入。因为moment. include_moment()会用来生成执行时间渲染的JavaScript函数，所以我们必须调用它，可以通过local_js参数传入本地资源的URL，如果不传入这个参数则会从CDN加载资源：\u003c/p>\u003cp>...         {{ moment.include_moment(local_js=url_for(&#x27;static&#x27;,  filename=&#x27;js/moment-with-             locales.min.js&#x27;)) }}         &lt;/body&gt;\u003c/p>\u003cp>注意\u003c/p>\u003cp>Moment.js官网提供的文件中moment.min.js仅包含英文语言的时间日期字符，如果要使用其他语言，需要下载moment-with-locales.min.js。\u003c/p>\u003cp>Flask-Moment默认以英文显示时间，我们可以传入区域字符串到locale ()方法来更改显示语言，下面将语言设为简体中文：\u003c/p>\u003cp>...         {{ moment.locale(&#x27;zh-cn&#x27;) }}         &lt;/body&gt;\u003c/p>\u003cp>附注\u003c/p>\u003cp>在Moment.js中，简体中文的地区字符串为“zh-cn”，中国香港繁体中文和中国台湾繁体中文，则分别使用为“zh-hk”和“zh-tw”。\u003c/p>\u003cp>除了使用locale参数固定地区，更合理的方式是根据用户浏览器或计算机的语言来设置语言，我们可以在locale()方法中将auto_detect参数设为True，这会自动探测客户端语言设置并选择合适的区域设置：\u003c/p>\u003cp>...         {{ moment.locale(auto_detect=True) }}         &lt;/body&gt;\u003c/p>\u003cp>7.4.3 渲染时间日期\u003c/p>\u003cp>Moment.js提供了非常丰富、灵活的时间日期格式化方式。在模板中，我们可以通过对moment类调用format()方法来格式化时间和日期，moment的构造方法接收使用utcnow()方法创建的datetime对象作为参数，即Message对象的timestamp属性。format()方法接收特定的格式字符串来渲染时间格式，比如：\u003c/p>\u003cp>{{ moment(timestamp).format(’格式字符串’) }}\u003c/p>\u003cp>提示\u003c/p>\u003cp>时间日期会在页面加载完成后执行Java Script函数使用Moment.js渲染，所以时间日期的显示会有微小的延迟。\u003c/p>\u003cp>Moment.js提供了一些内置的格式字符串，字符串及对应的中文输出示例如表7-4所示。\u003c/p>\u003cp>表7-4 Moment.js内置格式化字符串\u003c/p>\u003cp>提示\u003c/p>\u003cp>我们也可以通过Moment.js支持的时间单位参数自定义时间输出，比如使用格式字符串“YYYYMMMMDo ， ah:mm:ss”将会得到输出：2017七月26日，早上8:00:00。完整的参数及输出列表可以在这里看到：https://momentjs.com/docs/displaying/format/。\u003c/p>\u003cp>除了输出普通的时间日期，Moments.js还支持输出相对时间。比如相对于当前时间的“三分钟前”“一个月前”等。这通过from Now()方法实现，在新版本的Say Hello中，时间戳就使用这个函数渲染：\u003c/p>\u003cp>&lt;small&gt;{{ moment(message.timestamp).fromNow(refresh=True) }}&lt;/small&gt;\u003c/p>\u003cp>将refresh参数设为True（默认为False）可以让时间戳在不重载页面的情况下，随着时间的变化自动刷新。如果你在页面上等待一会儿，就会看到时间戳从“几秒前”变成了“1分钟前”。\u003c/p>\u003cp>附注\u003c/p>\u003cp>Flask-Moment实现了Moment.js的format()、from Now()、from Time()、calendar()、valueof()和unix()方法，具体的使用方法参见Moment.js文档（https://momentjs.com/docs/）。\u003c/p>\u003cp>有些时候，使用Flask-Moment提供的方法还不够灵活，这时可以手动使用Moment.js渲染时间日期。比如，当鼠标悬停在问候消息的时间日期上时，我们希望能够显示一个包含具体的绝对时间的弹出窗口（tooltip）。\u003c/p>\u003cp>为了能够在Java Script中使用Moment.js渲染时间日期，我们需要在显示相对时间的HTML元素中创建一个data-timestamp属性存储原始的时间戳，以便在Java Script中获取：\u003c/p>\u003cp>&lt;small data-toggle=&quot;tooltip&quot; data-placement=&quot;top&quot; data-delay=&quot;500&quot;         data-timestamp=&quot;{{ message.timestamp.strftime(&#x27;%Y-%m-%dT%H:%M:%SZ&#x27;) }}&quot;&gt;             {{ moment(message.timestamp).fromNow(refresh=True) }}         &lt;/small&gt;\u003c/p>\u003cp>注意\u003c/p>\u003cp>为了让时间戳能够正常被Moment.js解析，我们需要使用strftime()方法对原始的时间字符串按照ISO 8601标准进行格式化处理。\u003c/p>\u003cp>我们在script.js脚本存储Java Script代码，下面的Java Script代码将时间日期对应元素的tooltip内容设置为渲染后的时间日期：\u003c/p>\u003cp>$(function () {             function render_time() {                 return moment($(this).data(&#x27;timestamp&#x27;)).format(&#x27;lll&#x27;)             }             $(&#x27;[data-toggle=&quot;tooltip&quot;]&#x27;).tooltip(                 {title: render_time}             );         });\u003c/p>\u003cp>在Bootstrap中，Tooltip组件需要调用tooltip()方法进行初始化。我们使用data-toggle属性作为选择器选择所有设置了tooltip的元素，对其调用tooltip()方法。在调用这个方法时，可以传入一些选项，如title选项用来设置弹出的内容，可以是字符串也可以是函数对象。\u003c/p>\u003cp>在渲染时间日期的render_time()函数中，渲染时间日期使用的moment()函数是由Moment. js提供的，而不是Flask-Moment传入模板的类。$(this).data(&#x27;timestamp&#x27;)获取了对应元素的data-timestamp属性值，特殊变量this表示当前触发事件的元素对象。现在，当鼠标悬停在时间戳上时，会弹出包含具体时间的小窗口，如图7-5所示。\u003c/p>\u003cp>图7-5 包含具体时间的弹窗\u003c/p>\u003cp>附注\u003c/p>\u003cp>在Bootstrap中，Popover和Tooltip组件依赖于Java Script包Popper.js（https://popper. js.org/），要使用这两个组件，需确保在基模板中加载了对应的Java Script文件。作为替代，你也可以加载Bootstrap提供的合集包文件bootstrap.bundle.min.css。\u003c/p>\u003cp>7.5 使用Faker生成虚拟数据\u003c/p>\u003cp>创建虚拟数据是编写Web程序时的常见需求。在简单的场景下，我们可以手动创建一些虚拟数据，但更方便的选择是使用第三方库实现。流行的Python虚拟数据生成工具有Mimesis （https://github.com/lk-geimfari/mimesis）和Faker，后者同时支持Python2和Python3，而且文档中包含丰富的示例，所以这里将选用Faker。首先使用Pipenv安装（使用--dev选项声明为开发依赖）：\u003c/p>\u003cp>$ pipenv install faker --dev\u003c/p>\u003cp>Faker内置了20多类虚拟数据，包括姓名、地址、网络账号、信用卡、时间、职位、公司名称、Python数据等。要生成虚拟数据，首先要实例化Faker类，创建一个fake对象作为虚拟数据生成器：\u003c/p>\u003cp>&gt;&gt;&gt; from faker import Faker         &gt;&gt;&gt; fake = Faker()\u003c/p>\u003cp>这个fake对象可以使用分别对应所有虚拟数据类别的方法来获取虚拟数据，比如name、address、text等。每次调用都会获得不同的随机结果，一些基本示例如下所示：\u003c/p>\u003cp>&gt;&gt;&gt; from faker import Faker         &gt;&gt;&gt; fake = Faker()         &gt;&gt;&gt; fake.name()         &#x27;Lucy Cechtelar&#x27;         &gt;&gt;&gt; fake.address()         426 Jordy Lodge         Cartwrightshire, SC 88120-6700&quot;         &gt;&gt;&gt; fake.text()         Sint velit eveniet. Rerum atque repellat voluptatem quia rerum. Numquam excepturi         beatae sint laudantium consequatur. Magni occaecati itaque sint et sit tempore.         Nesciunt.\u003c/p>\u003cp>提示\u003c/p>\u003cp>你可以访问Faker官方文档的Providers一章（http://faker.readthedocs.io/en/master/providers.html）查看所有分类下可用的虚拟数据方法。\u003c/p>\u003cp>默认的虚拟数据语言为英文，如果你想获取其他语言的虚拟数据，可以在实例化Faker类时传入区域字符作为第一个参数（locale）来指定：\u003c/p>\u003cp>fake = Faker(&#x27;zh_CN&#x27;))\u003c/p>\u003cp>提示\u003c/p>\u003cp>在Faker中，简体中文和繁体中文对应的区域字符串分别为zh_CN和zh_TW。\u003c/p>\u003cp>在代码清单7-8中，我们使用Faker实现了一个生成虚拟留言数据的命令函数fake。\u003c/p>\u003cp>代码清单7-8 sayhello/commands.py：生成虚拟留言的命令\u003c/p>\u003cp>import click         from sayhello import app         ...         @app.cli.command()         @click.option(&#x27;--count&#x27;, default=20, help=&#x27;Quantity of messages, default is 20.&#x27;)         def forge(count):             &quot;&quot;&quot;Generate fake messages.&quot;&quot;&quot;             from faker import Faker             db.drop_all()             db.create_all()             fake = Faker()  # 创建用来生成虚拟数据的Faker实例             click.echo(&#x27;Working...&#x27;)             for i in range(count):                 message = Message(                     name=fake.name(),                     body=fake.sentence(),                     timestamp=fake.date_time_this_year()                 )                 db.session.add(message)             db.session.commit()             click.echo(&#x27;Created %d fake messages.&#x27; % count)\u003c/p>\u003cp>提示\u003c/p>\u003cp>使用for循环操作数据库时，为了提高效率，我们只需要在for循环结束后调用一次db.session.commit()方法提交数据库会话。\u003c/p>\u003cp>在这个命令函数前，我们使用click提供的option装饰器为命令添加数量选项--count，使用default关键字将默认值设为20。\u003c/p>\u003cp>为了方便测试，生成虚拟数据前会删除重建数据库表。我们分别调用fake对象的name()、sentence()、date_time_this_year()方法生成虚拟的姓名、留言和时间戳。现在使用下面的命令生成虚拟数据：\u003c/p>\u003cp>$ flask forge         Working...             Created 20 fake messages.\u003c/p>\u003cp>选项--count用来指定生成的留言数量，下面生成了50条虚拟留言：\u003c/p>\u003cp>$ flask forge --count=50         Working...             Created 50 fake messages.\u003c/p>\u003cp>现在运行程序，首页会显示一个很长的留言列表，根据创建的随机日期排序，最先发表的排在上面，如图7-6所示。\u003c/p>\u003cp>图7-6 虚拟留言列表\u003c/p>\u003cp>7.6 使用Flask-Debug Toolbar调试程序\u003c/p>\u003cp>扩展Flask-Debug Toolbar提供了一系列调试功能，可以用来查看请求的SQL语句、配置选项、资源加载情况等信息。这些信息在开发时会非常有用。首先使用Pipenv安装Flask-Debug Toolbar及其依赖：\u003c/p>\u003cp>$ pipenv install flask-debugtoolbar\u003c/p>\u003cp>然后实例化扩展提供的Debug Toolbar Extension类，传入程序实例app，以完成扩展的初始化：\u003c/p>\u003cp>from flask import Flask         ...         from flask_debugtoolbar import DebugToolbarExtension         app = Flask(__name__)         ...         toolbar = DebugToolbarExtension(app)\u003c/p>\u003cp>开发时不需要也不建议使用Flask-Debug Toolbar。Flask-Debug Toolbar只在开启了调试模式时才会启动，所以我们要确保设置正确的FLASK_ENV环境变量值：开发时设为development；部署时则设为production。另外，Flask-Debug Toolbar会拦截重定向请求，将DEBUG_TB_INTERCEPT_REDIRECTS配置变量设为False可以关闭这个特性：\u003c/p>\u003cp>DEBUG_TB_INTERCEPT_REDIRECTS = False\u003c/p>\u003cp>这时启动程序，就会发现页面右侧多了一个工具栏，单击“Hide”按钮可以隐藏为一个浮动按钮，如图7-7所示。\u003c/p>\u003cp>图7-7 开启调试工具栏后的界面\u003c/p>\u003cp>提示\u003c/p>\u003cp>在Say Hello的实际代码中并没有使用Flask-Debug Toolbar，这里只是演示。\u003c/p>\u003cp>在调试工具栏中，除了Flask版本以及页面的加载时间信息，右侧的功能选项分别为：HTTP首部、请求相关变量、配置变量、模板渲染记录、数据库查询记录、日志、路由列表、性能分析器。在第13章，我们会借助它来对Flask程序进行性能分析。图7-8显示了当前程序中的所有配置选项。\u003c/p>\u003cp>图7-8 使用调试工具栏查看程序配置\u003c/p>\u003cp>7.7 Flask配置的两种组织形式\u003c/p>\u003cp>在Flask中，开发和部署时通常需要不同的配置。比如，存储在SECRET_KEY配置变量的密钥，在开发时可以使用占位字符，但在生产环境下部署时则需要使用一个随机生成的字符串。为了区分，我们通常会有两种组织这种分离的方式。本书的示例程序均使用第一种方式，你可以自由选择。\u003c/p>\u003cp>7.7.1 环境变量优先\u003c/p>\u003cp>12-Factor程序第三条（https://www.12factor.net/zh_cn/config）建议通过环境变量来保存配置，以便将配置和程序分离开来，并且对不同场景下的配置进行分离。在第8章，我们将介绍如何通过Python类来组织不同场景下的配置变量。而从本书一开始，我们就创建了.env和.flaskenv来存储环境变量，对于包含敏感信息的配置，我们优先或仅从环境变量中读取，这些环境变量统一在.env文件中定义，从而实现了敏感配置的分离。因为我们在.gitignore中添加了这个文件，所以不会被提交进Git仓库。\u003c/p>\u003cp>7.7.2 实例文件夹覆盖\u003c/p>\u003cp>尽管在示例程序中并没有使用这个特性，但我们还是有必要介绍一下Flask中的实例文件夹（instance folder）。为了方便存储开发和部署时的各类文件，Flask提供了实例文件夹支持。你可以在项目根目录（程序包旁）中创建一个名称为instance的文件夹，在这个文件夹中存储开发或部署时使用的配置文件，包含敏感信息的文件，或是临时创建的数据库文件等。\u003c/p>\u003cp>注意\u003c/p>\u003cp>记得将这个实例文件夹加入.gitignore文件中，以确保不会提交到Git仓库中。\u003c/p>\u003cp>当使用实例文件夹存储配置时，一个方便的做法是把包含敏感数据的配置放到instance文件夹的配置文件中，外部只保留通用的公开配置。Flask允许加载多次配置，重复的配置以最后定义的配置为准，所以我们可以使用instance文件夹中的配置来覆盖通用配置：\u003c/p>\u003cp>app = Flask(__name__, instance_relative_config=True)         app.config.from_object(&#x27;config&#x27;)  # 通用配置         app.config.from_pyfile(&#x27;config.py&#x27;)  # instance文件夹下的配置\u003c/p>\u003cp>在创建程序实例时，我们将instance_relative_config参数True，这会告诉Flask我们的配置文件路径是相对于实例文件夹的（默认是相对于程序实例根目录的）。\u003c/p>\u003cp>临时的数据库文件也可以放到实例文件夹中，实例文件夹的路径可以通过app.instance_path属性获取，所以你可以使用下面的方法构建数据库URI：\u003c/p>\u003cp>SQLALCHEMY_DATABASE_URI = &#x27;sqlite:///&#x27; + os.path.join(app.instance_path, &#x27;data.             db&#x27;)\u003c/p>\u003cp>Flask不会自动创建实例文件夹，所以你需要手动创建。在单脚本程序中，实例文件夹在脚本旁创建；在使用程序包的程序中，实例文件夹在程序包旁创建。\u003c/p>\u003cp>提示\u003c/p>\u003cp>当我们使用flask shell命令时，输出的信息会给出实例文件夹的合适位置。\u003c/p>\u003cp>7.8 本章小结\u003c/p>\u003cp>本章基于Say Hello程序的编写复习了本书第一部分介绍的基础知识，并且介绍了基本的项目组织方法以及Web程序的基本开发流程。对于更大的项目，我们后面会学习使用工厂函数、蓝本等技术进一步组织项目。\u003c/p>\u003cp>附注\u003c/p>\u003cp>如果你发现了Say Hello程序中的错误或者有改进建议，可以在Say Hello的Git Hub项目（https://github.com/greyli/sayhello）中创建Issue，或是在fork仓库修改后并在Git Hub上提交Pull Request。\u003c/p>","title":"第7章 留言板","idx":12,"uid":12,"nextUid":13,"lastUid":11,"price":0};
    config.vueCatalog = {"bookId":"22987517","soldOut":0,"clearAll":0,"updated":[{"chapterUid":1,"chapterIdx":1,"updateTime":0,"title":"封面","wordCount":1,"price":0,"paid":0,"isMPChapter":0,"level":1,"files":["Text/coverpage.xhtml"]},{"chapterUid":2,"chapterIdx":2,"updateTime":0,"title":"版权信息","wordCount":142,"price":0,"paid":0,"isMPChapter":0,"level":1,"files":["Text/copyright.xhtml"]},{"chapterUid":3,"chapterIdx":3,"updateTime":0,"tar":"https://res.weread.qq.com/wrco/tar_22987517_3","title":"前言","wordCount":7711,"price":0,"paid":0,"isMPChapter":0,"level":1,"files":["Text/Chapter_1_1.xhtml"]},{"chapterUid":4,"chapterIdx":4,"updateTime":0,"tar":"https://res.weread.qq.com/wrco/tar_22987517_4","title":"第一部分 基础篇","wordCount":279,"price":0,"paid":0,"isMPChapter":0,"level":1,"files":["Text/Chapter_2_1.xhtml"]},{"chapterUid":5,"chapterIdx":5,"updateTime":0,"tar":"https://res.weread.qq.com/wrco/tar_22987517_5","title":"第1章 初识Flask","wordCount":23267,"price":0,"paid":0,"isMPChapter":0,"level":2,"files":["Text/Chapter_2_1_0001.xhtml"]},{"chapterUid":6,"chapterIdx":6,"updateTime":0,"tar":"https://res.weread.qq.com/wrco/tar_22987517_6","title":"第2章 Flask与HTTP","wordCount":42437,"price":0,"paid":0,"isMPChapter":0,"level":2,"files":["Text/Chapter_2_2.xhtml"]},{"chapterUid":7,"chapterIdx":7,"updateTime":0,"tar":"https://res.weread.qq.com/wrco/tar_22987517_7","title":"第3章 模板","wordCount":26300,"price":0,"paid":0,"isMPChapter":0,"level":2,"files":["Text/Chapter_2_3.xhtml"]},{"chapterUid":8,"chapterIdx":8,"updateTime":0,"tar":"https://res.weread.qq.com/wrco/tar_22987517_8","title":"第4章 表单","wordCount":35291,"price":0,"paid":0,"isMPChapter":0,"level":2,"files":["Text/Chapter_2_4.xhtml"]},{"chapterUid":9,"chapterIdx":9,"updateTime":0,"tar":"https://res.weread.qq.com/wrco/tar_22987517_9","title":"第5章 数据库","wordCount":42093,"price":0,"paid":0,"isMPChapter":0,"level":2,"files":["Text/Chapter_2_5.xhtml"]},{"chapterUid":10,"chapterIdx":10,"updateTime":0,"tar":"https://res.weread.qq.com/wrco/tar_22987517_10","title":"第6章 电子邮件","wordCount":14543,"price":0,"paid":0,"isMPChapter":0,"level":2,"files":["Text/Chapter_2_6.xhtml"]},{"chapterUid":11,"chapterIdx":11,"updateTime":0,"tar":"https://res.weread.qq.com/wrco/tar_22987517_11","title":"第二部分 实战篇","wordCount":331,"price":0,"paid":0,"isMPChapter":0,"level":1,"files":["Text/Chapter_3_1.xhtml"]},{"chapterUid":12,"chapterIdx":12,"updateTime":0,"tar":"https://res.weread.qq.com/wrco/tar_22987517_12","title":"第7章 留言板","wordCount":23030,"price":0,"paid":0,"isMPChapter":0,"level":2,"files":["Text/Chapter_3_1_0001.xhtml"]},{"chapterUid":13,"chapterIdx":13,"updateTime":0,"tar":"https://res.weread.qq.com/wrco/tar_22987517_13","title":"第8章 个人博客","wordCount":88601,"price":0,"paid":0,"isMPChapter":0,"level":2,"files":["Text/Chapter_3_2.xhtml"]},{"chapterUid":14,"chapterIdx":14,"updateTime":0,"tar":"https://res.weread.qq.com/wrco/tar_22987517_14","title":"第9章 图片社交网站","wordCount":144227,"price":-1,"paid":0,"isMPChapter":0,"level":2,"files":["Text/Chapter_3_3.xhtml"]},{"chapterUid":15,"chapterIdx":15,"updateTime":0,"tar":"https://res.weread.qq.com/wrco/tar_22987517_15","title":"第10章 待办事项程序","wordCount":70333,"price":-1,"paid":0,"isMPChapter":0,"level":2,"files":["Text/Chapter_3_4.xhtml"]},{"chapterUid":16,"chapterIdx":16,"updateTime":0,"tar":"https://res.weread.qq.com/wrco/tar_22987517_16","title":"第11章 在线聊天室","wordCount":53195,"price":-1,"paid":0,"isMPChapter":0,"level":2,"files":["Text/Chapter_3_5.xhtml"]},{"chapterUid":17,"chapterIdx":17,"updateTime":0,"tar":"https://res.weread.qq.com/wrco/tar_22987517_17","title":"第三部分 进阶篇","wordCount":216,"price":-1,"paid":0,"isMPChapter":0,"level":1,"files":["Text/Chapter_4_1.xhtml"]},{"chapterUid":18,"chapterIdx":18,"updateTime":0,"tar":"https://res.weread.qq.com/wrco/tar_22987517_18","title":"第12章 自动化测试","wordCount":29475,"price":-1,"paid":0,"isMPChapter":0,"level":2,"files":["Text/Chapter_4_1_0001.xhtml"]},{"chapterUid":19,"chapterIdx":19,"updateTime":0,"tar":"https://res.weread.qq.com/wrco/tar_22987517_19","title":"第13章 性能优化","wordCount":14780,"price":-1,"paid":0,"isMPChapter":0,"level":2,"files":["Text/Chapter_5_1.xhtml"]},{"chapterUid":20,"chapterIdx":20,"updateTime":0,"tar":"https://res.weread.qq.com/wrco/tar_22987517_20","title":"第14章 部署上线","wordCount":125293,"price":-1,"paid":0,"isMPChapter":0,"level":2,"files":["Text/Chapter_6_1.xhtml"],"anchors":[{"title":"第15章 Flask扩展开发","anchor":"sigil_toc_id_1","level":2},{"title":"第16章 Flask工作原理与机制解析","anchor":"sigil_toc_id_2","level":2}]},{"chapterUid":21,"chapterIdx":21,"updateTime":0,"title":"附录A Flask资源","wordCount":4384,"price":-1,"paid":0,"isMPChapter":0,"level":1,"files":["Text/Chapter_6_11.xhtml"]}],"removed":[],"synckey":1313596851,"book":{"bookId":"22987517","version":1313596851,"format":"epub","cover":"https://wfqqreader-1252317822.image.myqcloud.com/cover/517/22987517/s_22987517.jpg","title":"Flask Web开发实战：入门、进阶与原理解析","author":"李辉","price":89,"type":0}};
    config.vueReadingStat = {"readingCount":1892,"todayReadingCount":30,"friendReadingCount":1,"readingUsers":[{"userVid":8186776,"name":"徐雨桑","gender":2,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIQl7OT0JUKL1tzlejhAS8sBzxBdavT9AwItkQLfVrKsBxtOiaj27cANvNUKX0Ex43S3aTe4BgpkcQ/132"}],"recommendUsers":[]};
    config.vueReadSchedule = {"chapterUid":12,"chapterIdx":12,"paragraph":1,"time":1564969654,"title":"第7章 留言板","onShelf":1};
    config.userType = +'2';
    config.isNewDevice = 'false' === 'true';</script>   <script>config.paragraph = +'1';</script>  <script>(function () {
        var src = 'https://rescdn.qqmail.com/node/wr/wrwxnovel/js/lib/eruda$f8097017.js';
        if (!/eruda=true/.test(window.location) && localStorage.getItem('active-eruda') != 'true') return;
        document.write('<scr' + 'ipt src="' + src + '"></scr' + 'ipt>');
        document.write('<scr' + 'ipt>try {eruda.init(); } catch(e) {alert(JSON.stringify(e))}</scr' + 'ipt>');
    })();</script>  <script type="text/javascript" src="https://rescdn.qqmail.com/node/wr/wrwxnovel/js/lib/vue.min$502f016a.js"></script>  <script>Vue.options.delimiters = ['[{', '}]'];</script> <script type="text/javascript" src="https://rescdn.qqmail.com/node/wr/wrwxnovel/js/lib/vue-scrollto$655a94ac.js"></script> <script crossorigin="anonymous" type="text/javascript" src="https://rescdn.qqmail.com/node/wr/wrwxnovel/js/lib/weixin$8a92cad7.js"></script> <script crossorigin="anonymous" type="text/javascript" src="https://rescdn.qqmail.com/node/wr/wrwxnovel/js/eustia/WeChatSearch/verticalReader$bdd63e51.js"></script> <script crossorigin="anonymous" type="text/javascript" src="https://rescdn.qqmail.com/node/wr/wrwxnovel/js/WeChatSearch/verticalReader$c043165d.js"></script></div></div></div><div class="wr_toast" id="toast"></div>  <script>ready();</script></body></html>