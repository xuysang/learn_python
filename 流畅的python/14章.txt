第14章 可迭代的对象、迭代器和生成器
所有生成器都是迭代器，因为生成器完全实现了迭代器接口。不过，根据《设计模式：可复用面向对象软件的基础》一书的定义，迭代器用于从集合中取出元素；而生成器用于“凭空”生成元素。通过斐波纳契数列能很好地说明二者之间的区别：斐波纳契数列中的数有无穷个，在一个集合里放不下。不过要知道，在Python社区中，大多数时候都把迭代器和生成器视作同一概念。

在Python语言内部，迭代器用于支持：
<p>for循环</p>
<p>构建和扩展集合类型</p>
<p>逐行遍历文本文件</p>
<p>列表推导、字典推导和集合推导</p>
<p>元组拆包</p>
<p>调用函数时，使用*拆包实参

所有序列都可以迭代
序列可以迭代的原因：iter函数
解释器需要迭代对象x时，会自动调用iter(x)。内置的iter函数有以下作用。
(1)检查对象是否实现了__iter__方法，如果实现了就调用它，获取一个迭代器。
(2)如果没有实现__iter__方法，但是实现了__getitem__方法，Python会创建一个迭代器，尝试按顺序（从索引0开始）获取元素。
(3)如果尝试失败，Python抛出TypeError异常，通常会提示“C object is not iterable”（C对象不可迭代），其中C是目标对象所属的类。

任何Python序列都可迭代的原因是，它们都实现了__getitem__方法。其实，标准的序列也都实现了__iter__方法，因此你也应该这么做。之所以对__getitem__方法做特殊处理，是为了向后兼容，而未来可能不会再这么做

可迭代的对象
使用iter内置函数可以获取迭代器的对象。如果对象实现了能返回迭代器的__iter__方法，那么对象就是可迭代的。序列都可以迭代；实现了__getitem__方法，而且其参数是从零开始的索引，这种对象也可以迭代。

我们要明确可迭代的对象和迭代器之间的关系：Python从可迭代的对象中获取迭代器。

标准的迭代器接口有两个方法。
__next__：返回下一个可用的元素，如果没有元素了，抛出StopIteration异常。
__iter__：返回self，以便在应该使用可迭代对象的地方使用迭代器，例如在for循环中。