
第二章
容器序列存放的是它们所包含的任意类型的对象的引用，而扁平序列里存放的是值而不是引用。扁平序列其实是一段连续的内存空间。
容器序列：list、tuple和collections.deque
扁平序列：str、bytes、bytearray、memoryview和array.array

序列类型按照能否被修改来分类。
可变序列：list、bytearray、array.array、collections.deque和memoryview
不可变序列：tuple、str和bytes

生成器表达式：
虽然也可以用列表推导来初始化元组、数组或其他序列类型，但是生成器表达式是更好的选择。这是因为生成器表达式背后遵守了迭代器协议，可以逐个地产出元素，而不是先建立一个完整的列表，然后再把这个列表传递到某个构造函数里。前面那种方式显然能够节省内存。生成器表达式的语法跟列表推导差不多，只不过把方括号换成圆括号而已。

array.array('I', (ord(symbol) for symbol in symbols))
如果生成器表达式是一个函数调用过程中的唯一参数，那么不需要额外再用括号把它围起来。

for循环可以分别提取元组里的元素，也叫作拆包（unpacking）。因为元组中第二个元素对我们没有什么用，所以它赋值给“_”占位符。

元祖
1.最好辨认的元组拆包形式就是平行赋值，也就是说把一个可迭代对象里的元素，一并赋值到由对应的变量组成的元组中。
lax_coordinates = (33.9425,-118.408056) 
latitude, longitude = lax_coordinates
2.让一个函数可以用元组的形式返回多个值，然后调用函数的代码就能轻松地接受这些返回值。比如os.path.split（　）函数就会返回以路径和最后一个文件名组成的元组(path, last_part)
>>> filename=os.path.split('/home/lucoano/.ssh/idrsa.pub')
>>> filename
('/home/lucoano/.ssh', 'idrsa.pub')


3.函数用*args来获取不确定数量的参数
>>>a, b, *rest = range(5)
>>>a, b, rest 
(0, 1, [2, 3, 4])
在平行赋值中，*前缀只能用在一个变量名前面，但是这个变量可以出现在赋值表达式的任意位置：
>>>a, *b, rest = range(5)
>>>a, b, rest 
(0, [1, 2, 3], 4)

4.创建具名元祖需要两个参数，一个是类名，另一个是类的各个字段的名字。后者可以是由数个字符串组成的可迭代对象，或者是由空格分隔开的字段名组成的字符串。存放在对应字段里的数据要以一串参数的形式传入到构造函数中。可以通过字段名或者位置来获取一个字段的信息。
>>> from collections import namedtuple
>>> City = namedtuple('City','name country population coordinates')
>>> tokyo = City('Tokyo','JP',36.933,(35.689722,139.691667))
>>> tokyo
City(name='Tokyo', country='JP', population=36.933, coordinates=(35.689722, 139.691667))
>>> tokyo.population
36.933
>>> tokyo.coordinates
(35.689722, 139.691667)
>>> tokyo[1]
'JP'
具名元祖专有属性：_fields属性是包含这个类所有字段名称的元祖。_make()通过接受一个可迭代对象来生成类的一个实例。_asdict()把具名元祖以collections.OrderDict的形式返回。

不要把可变对象放在元祖里

第三章
只有可散列的数据类型才能用作映射里的键。
可散列类型：如果一个对象是可散列的，在这个对象的生命周期中，散列值是不变的，而且这个对象需要实现__hash__()方法。另外可散列对象还要有__eq__()方法，这样才能和其他键做比较。如果两个可散列对象是相等的，那么它们的散列值是一样的。
原子不可变数据类型（str、bytes和数值类型）都是可散列类型，frozenset也是可散列的。元祖，只有当一个元祖包含的所有元素是可散列类型的情况下才是可散列的。
1.字典的构造方法：
>>> a = dict(one=1,two=2,three=3)
>>> b = {'one':1,'two':2,'three':3}
>>> c = dict(zip(['one','two','three'],[1,2,3]))
>>> d = dict([('two',2),('one',1),('three',3)])
>>> e = dict({'three':3,'one':1,'two':2})
>>> a==b==c==d==e
True

2.字典推导
字典推导可以从任何以键值对作为元素的可迭代对象中构建出字典。

用setdefault处理找不到的键
my_dict.setdefault(key,[]).append(new_value)
等同于
If key not in my_dict:
    my_dict[key] = []
my_dict[key].append(new_value)

集合的本质是许多唯一对象的聚集。
空集必须写成set()

第五章
函数
def factorial(n):
    '''return n!'''
    return 1 if n<2 else n*factorial(n-1)

>>> factorial.__doc__
'return n!'
__doc__是函数对象众多属性中的一个，factorial是function类的实例

接受函数为参数，或者把函数作为结果返回的函数是高阶函数，例如(map,filter,reduce)
使用不定量的参数调用函数，可以编写fn(*args,**keywords)

可调用对象（7种）
1.用户定义的函数（使用def语句或lambda表达式创建）
2.内置函数（使用C语言（CPython）实现的函数，如len或time.strftime
3.内置方法（使用C语言实现的方法，如dict.get）
4.方法（在类的定义体中定义的函数）
5.类（调用类时会运行类的__new__方法创建一个实例，然后运行__init__方法，初始化实例，最后把实例返回给调用方。因为python没有new运算符，所以调用类相当于调用函数）
6.类的实例（如果类定义了__call__方法，那么它的实例可以作为函数调用）
7.生成器函数（使用yield关键字的函数或方法，调用生成器函数返回的是生成器对象）

判断对象能否调用，最安全的方法是使用内置的callable()函数。
>>> [callable(obj) for obj in (abs,str,13)]
[True, True, False]

相等但不是
== 表明值是否相等（对象中保存的数据）
is 比较对象的标识（对象在内存中的地址）
在变量和单利值直接比较时，应该使用is  (x is None/x is not None)
is运算符比==速度快
浅复制，list与turple一开始引用是相同的，后面列表改变是就地改变，元祖改变是创建了新的元祖
深复制，副本不共享内部对象的引用
copy模块提供的deepcopy和copy函数能为任意对象做深复制和浅复制

不要使用可变类型作为参数的默认值

垃圾回收
del命令可能会导致对象被当做垃圾回收。但是仅当删除的变量保存的是对象的最后一个引用，或者无法得到对象时。

弱引用
WeakValueDictionary类实现的是一种可变映射，里面的值是对象的弱引用。被引用的对象在程序中的其他地方被当做垃圾回收后，对应的键会自动从WeakValueDictionary中删除。因此WeakValueDictionary经常用于缓存。
with open('test.txt','wt',encoding='utf-8') as fp:
    fp.write('1,2,3')

对象表示形式
repr()：以便于开发者理解的方式返回对象的字符串表示形式
str()：以便于用户理解的方式返回对象的字符串表示形式

@classmethod
def frombytes(cls,octets):
  typecode = chr(octets[0])
  memv = memoryview(octets[1:]).cast(typecode)
  return cls(*memv)

@classmethod
定义操作类，而不是操作实例的方法。classmethod改变调用方法的方式，第一个参数是类本身，不是实例。classmethod最常见的用途是定义备选构造方法。按照约定，类方法的第一个参数名为cls

格式化显示
内置的format（ ）函数和str.format（ ）方法把各个类型的格式化方式委托给相应的.__format__(format_spec)方法。format_spec是格式说明符，它是：format(my_obj, format_spec)的第二个参数，或者str.format（ ）方法的格式字符串，{}里代换字段中冒号后面的部分
>>> brl=1/2.43
>>> brl
0.4115226337448559
>>> format(brl,'0.4f')
'0.4115'
>>> '1 BRL={rate:0.2f} USD'.format(rate=brl)
'1 BRL=0.41 USD'

format函数
格式规范微语言，b和x表示二进制和十六进制的int类型，f表示小数形式的float类型，%表示百分数形式。
>>> format(42,'b')
'101010'
>>> format(2/3,'.1%')
'66.7%'


使用两个前导下划线（尾部没有下划线，或者有一个下划线），把属性标记为私有的
注意，我们让这些向量不可变是有原因的，因为这样才能实现__hash__方法。这个方法应该返回一个整数，理想情况下还要考虑对象属性的散列值（__eq__方法也要使用），因为相等的对象应该具有相同的散列值。根据特殊方法__hash__的文档，最好使用位运算符异或（^）混合各分量的散列值


有人编写了一个名为Dog的类，这个类的内部用到了mood实例属性，但是没有将其开放。现在，你创建了Dog类的子类：Beagle。如果你在毫不知情的情况下又创建了名为mood的实例属性，那么在继承的方法中就会把Dog类的mood属性覆盖掉。这是个难以调试的问题。为了避免这种情况，如果以__mood的形式（两个前导下划线，尾部没有或最多有一个下划线）命名实例属性，Python会把属性名存入实例的__dict__属性中，而且会在前面加上一个下划线和类名。因此，对Dog类来说，__mood会变成_Dog__mood；对Beagle类来说，会变成_Beagle__mood。这个语言特性叫名称改写（name mangling）

super（　）函数用于动态访问超类的方法，对Python这样支持多重继承的动态语言来说，必须能这么做。程序员经常使用这个函数把子类方法的某些任务委托给超类中适当的方法。12.2节会进一步探讨super（　）函数。

我们知道，在类中声明__slots__属性可以防止设置新实例属性；因此，你可能想使用这个功能，而不像这里所做的，实现__setattr__方法。可是，正如9.8.1节所指出的，不建议只为了避免创建实例属性而使用__slots__属性。__slots__属性只应该用于节省内存，而且仅当内存严重不足时才应该这么做。

之前我说reduce没有以往那么常用，但是计算向量所有分量的散列值非常适合使用这个函数。归约函数（reduce、sum、any、all）把序列或有限的可迭代对象变成一个聚合结果。

我们已经知道functools.reduce（　）可以替换成sum（　），下面说说它的原理。它的关键思想是，把一系列值归约成单个值。reduce（　）函数的第一个参数是接受两个参数的函数，第二个参数是一个可迭代的对象。假如有个接受两个参数的fn函数和一个lst列表。调用reduce(fn, lst)时，fn会应用到第一对元素上，即fn(lst[0], lst[1])，生成第一个结果r1。然后，fn会应用到r1和下一个元素上，即fn(r1, lst[2])，生成第二个结果r2。接着，调用fn(r2, lst[3])，生成r3……直到最后一个元素，返回最后得到的结果rN。

使用reduce函数时最好提供第三个参数，reduce(function, iterable, initializer)，这样能避免这个异常：TypeError: reduce（　） of empty sequence with no initial value（这个错误消息很棒，说明了问题，还提供了解决方法）。如果序列为空，initializer是返回的结果；否则，在归约中使用它作为第一个参数，因此应该使用恒等值。比如，对+、|和^来说， initializer应该是0；而对*和&来说，应该是1。


第十一章  接口：从协议到抽象基类

首先，本章说明抽象基类的常见用途：实现接口时作为超类使用。然后，说明抽象基类如何检查具体子类是否符合接口定义，以及如何使用注册机制声明一个类实现了某个接口，而不进行子类化操作。最后，说明如何让抽象基类自动“识别”任何符合接口的类――不进行子类化或注册。

本章首先介绍了非正式接口（称为协议）的高度动态本性，然后讲解了抽象基类的静态接口声明，最后指出了抽象基类的动态特性：虚拟子类，以及使用__subclasshook__方法动态识别子类。

如果一门语言很少隐式转换类型，说明它是强类型语言；如果经常这么做，说明它是弱类型语言。Java、C++和Python是强类型语言。PHP、JavaScript和Perl是弱类型语言。

在编译时检查类型的语言是静态类型语言，在运行时检查类型的语言是动态类型语言。静态类型需要声明类型（有些现代语言使用类型推导避免部分类型声明）。Fortran和Lisp是最早的两门语言，现在仍在使用，它们分别是静态类型语言和动态类型语言。

第十二章  继承的优缺点

内置的类，和自定义的类有相同功能的时候，内置的类会忽略自定义的类，只有按照自定义的方式才能执行自定义的方法。内置类型方法不会调用子类覆盖的方法。

直接子类化内置类型（如dict、list或str）容易出错，因为内置类型的方法通常会忽略用户覆盖的方法。不要子类化内置类型，用户自己定义的类应该继承collections模块中的类，例如UserDict、UserList和UserString，这些类做了特殊设计，因此易于扩展。

类都有一个名为__mro__的属性，它的值是一个元组，按照方法解析顺序列出各个超类，从当前类一直向上，直到object类。

把接口继承和实现继承区分开
使用多重继承时，一定要明确一开始为什么创建子类。主要原因可能有：
    继承接口，创建子类型，实现“是什么”关系
    继承实现，通过重用避免代码重复
其实这两条经常同时出现，不过只要可能，一定要明确意图。通过继承重用代码是实现细节，通常可以换用组合和委托模式。而接口继承则是框架的支柱。
使用抽象基类显式表示接口。现代的Python中，如果类的作用是定义接口，应该明确把它定义为抽象基类。

如果一个类的作用是为多个不相关的子类提供方法实现，从而实现重用，但不体现“是什么”关系，应该把那个类明确地定义为混入类（mixin class）。从概念上讲，混入不定义新类型，只是打包方法，便于重用。混入类绝对不能实例化，而且具体类不能只继承混入类。混入类应该提供某方面的特定行为，只实现少量关系非常紧密的方法。

使用抽象基类时，多重继承很常见，而且实际上也是不可避免的，因为最基本的集合抽象基类（Sequence、Mapping和Set）都扩展多个抽象基类。

第十三章  正确重载运算符

第十五章  上下文管理器和else块

for/else、while/else、try/else
else子句的行为如下:
1.仅当for循环运行完毕时（即for循环没有被break语句中止）才运行else块。
2.仅当while循环因为条件为假值而退出时（即while循环没有被break语句中止）才运行else块。
3.仅当try块中没有异常抛出时才运行else块。官方文档还指出：“else子句抛出的异常不会由前面的except子句处理。”
在所有情况下，如果异常或者return、break或continue语句导致控制权跳到了复合语句的主块之外，else子句也会被跳过。
EAFP:
取得原谅比获得许可容易（easier to ask for forgiveness than permission）。这是一种常见的Python编程风格，先假定存在有效的键或属性，如果假定不成立，那么捕获异常。这种风格简单明快，特点是代码中有很多try和except语句。与其他很多语言一样（如C语言），这种风格的对立面是LBYL风格。
LBYL:
三思而后行（look before you leap）。这种编程风格在调用函数或查找属性或键之前显式测试前提条件。与EAFP风格相反，这种风格的特点是代码中有很多if语句。在多线程环境中，LBYL风格可能会在“检查”和“行事”的空当引入条件竞争。例如，对if key in mapping: return mapping[key]这段代码来说，如果在测试之后，但在查找之前，另一个线程从映射中删除了那个键，那么这段代码就会失败。这个问题可以使用锁或者EAFP风格解决。

第十六章：协程
使用yield from句法调用协程时，会自动预激，因此与示例16-5中的@coroutine等装饰器不兼容。Python 3.4标准库里的asyncio.coroutine装饰器（第18章介绍）不会预激协程，因此能兼容yield from句法。

委派生成器：包含yield from <iterable>表达式的生成器函数。
子生成器：从yield from表达式中<iterable>部分获取的生成器。
调用方:PEP 380使用“调用方”这个术语指代调用委派生成器的客户端代码。在不同的语境中，我会使用“客户端”代替“调用方”，以此与委派生成器（也是调用方，因为它调用了子生成器）区分开。

第十八章：使用asyncio包处理并发  Concurrency Is Not Parallelism (It's Better)[“并发不是并行（并发更好）”]
真正的并行需要多个核心。现代的笔记本电脑有4个CPU核心，但是通常不经意间就有超过100个进程同时运行。因此，实际上大多数过程都是并发处理的，而不是并行处理。计算机始终运行着100多个进程，确保每个进程都有机会取得进展，不过CPU本身同时做的事情不能超过四件。十年前使用的设备也能并发处理100个进程，不过都在同一个核心里。

Task对象用于驱动协程，Thread对象用于调用可调用的对象。